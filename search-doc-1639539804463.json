[{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil }  "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → any) → Connection Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire( ...: any-- Arguments to pass to the server ) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object. "},{"title":"Comm","type":0,"sectionRef":"#","url":"api/Comm","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Comm","url":"api/Comm#properties","content":" "},{"title":"ServerComm​","type":1,"pageTitle":"Comm","url":"api/Comm#ServerComm","content":"&lt;/&gt; Comm.ServerComm: ServerComm   "},{"title":"ClientComm​","type":1,"pageTitle":"Comm","url":"api/Comm#ClientComm","content":"&lt;/&gt; Comm.ClientComm: ClientComm  "},{"title":"ClientComm","type":0,"sectionRef":"#","url":"api/ClientComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#types","content":" "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#new","content":"&lt;/&gt; ClientComm.new( parent: Instance , usePromise: boolean, namespace: string? ) → ClientComm Constructs a ClientComm object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds.  "},{"title":"GetFunction​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#GetFunction","content":"&lt;/&gt; ClientComm:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerComm. The function can then be called to invoke the server. If this ClientComm object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverComm = ServerComm.new(someParent) serverComm:BindFunction(&quot;MyFunction&quot;, function(player, msg) return msg:upper() end) -- Client-side: local clientComm = ClientComm.new(someParent) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientComm = ClientComm.new(someParent, true) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#GetSignal","content":"&lt;/&gt; ClientComm:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerComm with the same matching name.  "},{"title":"BuildObject​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#BuildObject","content":"&lt;/&gt; ClientComm:BuildObject( inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → table Returns an object which maps RemoteFunctions as methods and RemoteEvents as fields. -- Server-side: serverComm:BindFunction(&quot;Test&quot;, function(player) end) serverComm:CreateSignal(&quot;MySignal&quot;) -- Client-side local obj = clientComm:BuildObject() obj:Test() obj.MySignal:Connect(function() end)   "},{"title":"Destroy​","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#Destroy","content":"&lt;/&gt; ClientComm:Destroy() → () Destroys the ClientComm object. "},{"title":"EnumList","type":0,"sectionRef":"#","url":"api/EnumList","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"EnumList","url":"api/EnumList#types","content":" "},{"title":"EnumItem​","type":1,"pageTitle":"EnumList","url":"api/EnumList#EnumItem","content":"&lt;/&gt; interface EnumItem { Name: string Value: number EnumType: EnumList }  "},{"title":"Functions​","type":1,"pageTitle":"EnumList","url":"api/EnumList#functions","content":" "},{"title":"new​","type":1,"pageTitle":"EnumList","url":"api/EnumList#new","content":"&lt;/&gt; EnumList.new( name: string, enums: {string} ) → EnumList Constructs a new EnumList. local directions = EnumList.new(&quot;Directions&quot;, { &quot;Up&quot;, &quot;Down&quot;, &quot;Left&quot;, &quot;Right&quot;, }) local direction = directions.Up   "},{"title":"BelongsTo​","type":1,"pageTitle":"EnumList","url":"api/EnumList#BelongsTo","content":"&lt;/&gt; EnumList:BelongsTo(obj: any) → boolean Returns true if obj belongs to the EnumList.  "},{"title":"GetEnumItems​","type":1,"pageTitle":"EnumList","url":"api/EnumList#GetEnumItems","content":"since v2.0.0 &lt;/&gt; EnumList:GetEnumItems() → {EnumItem} Returns an array of all enum items.  "},{"title":"GetName​","type":1,"pageTitle":"EnumList","url":"api/EnumList#GetName","content":"since v2.0.0 &lt;/&gt; EnumList:GetName() → string Get the name of the enum. "},{"title":"Input","type":0,"sectionRef":"#","url":"api/Input","content":"On this page Input The Input module provides access to various user input classes. PreferredInput Mouse Keyboard Touch local Input = require(packages.Input) local PreferredInput = Input.PreferredInput local Mouse = Input.Mouse local Keyboard = Input.Keyboard local Touch = Input.Touch ","keywords":""},{"title":"Keyboard","type":0,"sectionRef":"#","url":"api/Keyboard","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#properties","content":" "},{"title":"KeyDown​","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#KeyDown","content":"Event &lt;/&gt; Keyboard.KeyDown: Signal&lt;Enum.KeyCode&gt; Fired when a key is pressed. keyboard.KeyDown:Connect(function(key: KeyCode) print(&quot;Key pressed&quot;, key) end)   "},{"title":"KeyUp​","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#KeyUp","content":"Event &lt;/&gt; Keyboard.KeyUp: Signal&lt;Enum.KeyCode&gt; Fired when a key is released. keyboard.KeyUp:Connect(function(key: KeyCode) print(&quot;Key released&quot;, key) end)  "},{"title":"Functions​","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#new","content":"&lt;/&gt; Keyboard.new() → Keyboard Constructs a new keyboard input capturer. local keyboard = Keyboard.new()   "},{"title":"IsKeyDown​","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#IsKeyDown","content":"&lt;/&gt; Keyboard:IsKeyDown(keyCode: Enum.KeyCode) → isDown: boolean Returns true if the key is down. local w = keyboard:IsKeyDown(Enum.KeyCode.W) if w then ... end   "},{"title":"AreKeysDown​","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#AreKeysDown","content":"&lt;/&gt; Keyboard:AreKeysDown( keyCodeOne: Enum.KeyCode, keyCodeTwo: Enum.KeyCode ) → areKeysDown: boolean Returns true if both keys are down. Useful for key combinations. local shiftA = keyboard:AreKeysDown(Enum.KeyCode.LeftShift, Enum.KeyCode.A) if shiftA then ... end   "},{"title":"Destroy​","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#Destroy","content":"&lt;/&gt; Keyboard:Destroy() → () Destroy the keyboard input capturer. "},{"title":"Loader","type":0,"sectionRef":"#","url":"api/Loader","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Loader","url":"api/Loader#functions","content":" "},{"title":"LoadChildren​","type":1,"pageTitle":"Loader","url":"api/Loader#LoadChildren","content":"&lt;/&gt; Loader.LoadChildren( parent: Instance -- Parent to scan ) → {ModuleScript }-- Array of required modules Requires all children ModuleScripts  "},{"title":"LoadDescendants​","type":1,"pageTitle":"Loader","url":"api/Loader#LoadDescendants","content":"&lt;/&gt; Loader.LoadDescendants( parent: Instance -- Parent to scan ) → {ModuleScript }-- Array of required modules Requires all descendant ModuleScripts "},{"title":"Component","type":0,"sectionRef":"#","url":"api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → nil   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"api/Component#Extension","content":"&lt;/&gt; interface Extension { Constructing: ExtensionFn? Constructed: ExtensionFn? Starting: ExtensionFn? Started: ExtensionFn? Stopping: ExtensionFn? Stopped: ExtensionFn? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components. For instance, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.Constructing(component) print(&quot;Constructing&quot;, component) end function Logger.Constructed(component) print(&quot;Constructed&quot;, component) end function Logger.Starting(component) print(&quot;Starting&quot;, component) end function Logger.Started(component) print(&quot;Started&quot;, component) end function Logger.Stopping(component) print(&quot;Stopping&quot;, component) end function Logger.Stopped(component) print(&quot;Stopped&quot;, component) end local MyComponent = Component.new({Tag = &quot;MyComponent&quot;, Extensions = {Logger}})   "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { Tag: string-- CollectionService tag to use Ancestors: {Instance }?-- Optional array of ancestors in which components will be started Extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no Ancestors option is included, it defaults to {workspace, game.Players}. If no Extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"api/Component#properties","content":" "},{"title":"Started​","type":1,"pageTitle":"Component","url":"api/Component#Started","content":"&lt;/&gt; Component.Started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Started:Connect(function(component) end)   "},{"title":"Stopped​","type":1,"pageTitle":"Component","url":"api/Component#Stopped","content":"&lt;/&gt; Component.Stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) MyComponent.Stopped:Connect(function(component) end)  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"api/Component#new","content":"&lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ Tag = &quot;MyComponent&quot;, Ancestors = {workspace}, Extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:Construct() self.MyData = &quot;Hello&quot; end function MyComponent:Start() local another = self:GetComponent(AnotherComponent) another:DoSomething() end function MyComponent:Stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:HeartbeatUpdate(dt) end function MyComponent:SteppedUpdate(dt) end function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"FromInstance​","type":1,"pageTitle":"Component","url":"api/Component#FromInstance","content":"&lt;/&gt; Component.FromInstance( instance: Instance , componentClass: ComponentClass ) → Component? Gets an instance of a component class given the Roblox instance and the component class. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = Component.FromInstance(workspace.SomeInstance, MyComponent)   "},{"title":"HeartbeatUpdate​","type":1,"pageTitle":"Component","url":"api/Component#HeartbeatUpdate","content":"&lt;/&gt; Component.HeartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:HeartbeatUpdate(dt) end   "},{"title":"SteppedUpdate​","type":1,"pageTitle":"Component","url":"api/Component#SteppedUpdate","content":"&lt;/&gt; Component.SteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:SteppedUpdate(dt) end   "},{"title":"RenderSteppedUpdate​","type":1,"pageTitle":"Component","url":"api/Component#RenderSteppedUpdate","content":"This item only works when running on the client. Client &lt;/&gt; Component.RenderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:RenderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:RenderSteppedUpdate(dt) end   "},{"title":"Construct​","type":1,"pageTitle":"Component","url":"api/Component#Construct","content":"&lt;/&gt; Component:Construct() → () Construct is called before the component is started, and should be used to construct the component instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"Start​","type":1,"pageTitle":"Component","url":"api/Component#Start","content":"&lt;/&gt; Component:Start() → () Start is called when the component is started. At this point in time, it is safe to grab other components also bound to the same instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() -- e.g., grab another component: local another = self:GetComponent(AnotherComponent) end   "},{"title":"Stop​","type":1,"pageTitle":"Component","url":"api/Component#Stop","content":"&lt;/&gt; Component:Stop() → () Stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.Instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) function MyComponent:Stop() self.SomeStuff:Destroy() end   "},{"title":"GetComponent​","type":1,"pageTitle":"Component","url":"api/Component#GetComponent","content":"&lt;/&gt; Component:GetComponent(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({Tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:Start() local another = self:GetComponent(AnotherComponent) end  "},{"title":"Mouse","type":0,"sectionRef":"#","url":"api/Mouse","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Mouse","url":"api/Mouse#properties","content":" "},{"title":"LeftDown​","type":1,"pageTitle":"Mouse","url":"api/Mouse#LeftDown","content":"Event &lt;/&gt; Mouse.LeftDown: Signal   "},{"title":"LeftUp​","type":1,"pageTitle":"Mouse","url":"api/Mouse#LeftUp","content":"Event &lt;/&gt; Mouse.LeftUp: Signal   "},{"title":"RightDown​","type":1,"pageTitle":"Mouse","url":"api/Mouse#RightDown","content":"Event &lt;/&gt; Mouse.RightDown: Signal   "},{"title":"RightUp​","type":1,"pageTitle":"Mouse","url":"api/Mouse#RightUp","content":"Event &lt;/&gt; Mouse.RightUp: Signal   "},{"title":"Scrolled​","type":1,"pageTitle":"Mouse","url":"api/Mouse#Scrolled","content":"Event &lt;/&gt; Mouse.Scrolled: Signal&lt;number&gt; mouse.Scrolled:Connect(function(scrollAmount) ... end)  "},{"title":"Functions​","type":1,"pageTitle":"Mouse","url":"api/Mouse#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Mouse","url":"api/Mouse#new","content":"&lt;/&gt; Mouse.new() → Mouse Constructs a new mouse input capturer. local mouse = Mouse.new()   "},{"title":"IsLeftDown​","type":1,"pageTitle":"Mouse","url":"api/Mouse#IsLeftDown","content":"&lt;/&gt; Mouse:IsLeftDown() → isLeftDown: boolean   "},{"title":"IsRightDown​","type":1,"pageTitle":"Mouse","url":"api/Mouse#IsRightDown","content":"&lt;/&gt; Mouse:IsRightDown() → isRightDown: boolean   "},{"title":"GetPosition​","type":1,"pageTitle":"Mouse","url":"api/Mouse#GetPosition","content":"&lt;/&gt; Mouse:GetPosition() → screenPosition: Vector2  Gets the 2D mouse position on the screen.  "},{"title":"GetDelta​","type":1,"pageTitle":"Mouse","url":"api/Mouse#GetDelta","content":"&lt;/&gt; Mouse:GetDelta() → deltaScreenPosition: Vector2   Only When Mouse Locked Getting the mouse delta is only intended for when the mouse is locked. If the mouse is not locked, this will return a zero Vector2. The mouse can be locked using the mouse:Lock() and mouse:LockCenter() method.  "},{"title":"GetRay​","type":1,"pageTitle":"Mouse","url":"api/Mouse#GetRay","content":"&lt;/&gt; Mouse:GetRay(overridePos: Vector2? ) → viewportMouseRay: Ray  Returns the viewport point ray for the mouse at the current mouse position (or the override position if provided).  "},{"title":"Raycast​","type":1,"pageTitle":"Mouse","url":"api/Mouse#Raycast","content":"&lt;/&gt; Mouse:Raycast( raycastParams: RaycastParams, distance: number?, overridePos: Vector2? ) → result: RaycastResult? Performs a raycast operation out from the mouse position (or theoverridePos if provided) into world space. The ray will go distance studs forward (or 1000 studs if not provided). Returns the RaycastResult if something was hit, else returns nil.  "},{"title":"Lock​","type":1,"pageTitle":"Mouse","url":"api/Mouse#Lock","content":"&lt;/&gt; Mouse:Lock() → () Locks the mouse in its current position on screen. Call mouse:Unlock() to unlock the mouse. Must explicitly unlock Be sure to explicitly call mouse:Unlock() before cleaning up the mouse. The Destroy method does not unlock the mouse since there is no way to guarantee who &quot;owns&quot; the mouse lock.  "},{"title":"LockCenter​","type":1,"pageTitle":"Mouse","url":"api/Mouse#LockCenter","content":"&lt;/&gt; Mouse:LockCenter() → () Locks the mouse in the center of the screen. Call mouse:Unlock() to unlock the mouse. Must explicitly unlock See cautionary in Lock method above.  "},{"title":"Unlock​","type":1,"pageTitle":"Mouse","url":"api/Mouse#Unlock","content":"&lt;/&gt; Mouse:Unlock() → () Unlocks the mouse.  "},{"title":"Destroy​","type":1,"pageTitle":"Mouse","url":"api/Mouse#Destroy","content":"&lt;/&gt; Mouse:Destroy() → () Destroys the mouse. "},{"title":"Log","type":0,"sectionRef":"#","url":"api/Log","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Log","url":"api/Log#types","content":" "},{"title":"LogItem​","type":1,"pageTitle":"Log","url":"api/Log#LogItem","content":"&lt;/&gt; interface LogItem { Log: ( message: any, customData: table? )-- Log the message Every: (n: number)-- Log only every n times AtMostEvery: ( n: number, timeUnit: TimeUnit )-- Log only every n TimeUnit Throw: ()-- Throw an error Wrap: ()-- Returns a function that can be called which will log out the given arguments Assert: ( condition: boolean, args: ... )-- Assert the condition }   "},{"title":"TimeUnit​","type":1,"pageTitle":"Log","url":"api/Log#TimeUnit","content":"&lt;/&gt; interface TimeUnit { Milliseconds: number Seeconds: number Minutes: number Hours: number Days: number Weeks: number Months: number Years: number }   "},{"title":"Level​","type":1,"pageTitle":"Log","url":"api/Log#Level","content":"&lt;/&gt; interface Level { Trace: number Debug: number Info: number Warning: number Error: number Fatal: number }  "},{"title":"Properties​","type":1,"pageTitle":"Log","url":"api/Log#properties","content":" "},{"title":"TimeUnit​","type":1,"pageTitle":"Log","url":"api/Log#TimeUnit","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Log.TimeUnit: TimeUnit   "},{"title":"Level​","type":1,"pageTitle":"Log","url":"api/Log#Level","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Log.Level: Level  "},{"title":"Functions​","type":1,"pageTitle":"Log","url":"api/Log#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Log","url":"api/Log#new","content":"&lt;/&gt; Log.new() → Log Construct a new Log object. warning This should only be called once per script.  "},{"title":"At​","type":1,"pageTitle":"Log","url":"api/Log#At","content":"&lt;/&gt; Log:At(level: LogLevel) → LogItem   "},{"title":"AtTrace​","type":1,"pageTitle":"Log","url":"api/Log#AtTrace","content":"&lt;/&gt; Log:AtTrace() → LogItem Get a LogItem at the Trace log level.  "},{"title":"AtDebug​","type":1,"pageTitle":"Log","url":"api/Log#AtDebug","content":"&lt;/&gt; Log:AtDebug() → LogItem Get a LogItem at the Debug log level.  "},{"title":"AtInfo​","type":1,"pageTitle":"Log","url":"api/Log#AtInfo","content":"&lt;/&gt; Log:AtInfo() → LogItem Get a LogItem at the Info log level.  "},{"title":"AtWarning​","type":1,"pageTitle":"Log","url":"api/Log#AtWarning","content":"&lt;/&gt; Log:AtWarning() → LogItem Get a LogItem at the Warning log level.  "},{"title":"AtError​","type":1,"pageTitle":"Log","url":"api/Log#AtError","content":"&lt;/&gt; Log:AtError() → LogItem Get a LogItem at the Error log level.  "},{"title":"AtFatal​","type":1,"pageTitle":"Log","url":"api/Log#AtFatal","content":"&lt;/&gt; Log:AtFatal() → LogItem Get a LogItem at the Fatal log level.  "},{"title":"Assert​","type":1,"pageTitle":"Log","url":"api/Log#Assert","content":"&lt;/&gt; Log:Assert( condition: boolean, ...: any ) → () Asserts the condition and then logs the following arguments at the Error level if the condition fails. "},{"title":"PID","type":0,"sectionRef":"#","url":"api/PID","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"PID","url":"api/PID#properties","content":" "},{"title":"POnE​","type":1,"pageTitle":"PID","url":"api/PID#POnE","content":"&lt;/&gt; PID.POnE: boolean POnE stands for &quot;Proportional on Error&quot;. Set to true by default. true: The PID applies the proportional calculation on the error. false: The PID applies the proportional calculation on the measurement. Setting this value to false may help the PID move smoother and help eliminate overshoot. local pid = PID.new(...) pid.POnE = true|false  "},{"title":"Functions​","type":1,"pageTitle":"PID","url":"api/PID#functions","content":" "},{"title":"new​","type":1,"pageTitle":"PID","url":"api/PID#new","content":"&lt;/&gt; PID.new( min: number,-- Minimum value the PID can output max: number,-- Maximum value the PID can output kp: number,-- Proportional coefficient ki: number,-- Integral coefficient kd: number-- Derivative coefficient ) → PID Constructs a new PID. local pid = PID.new(0, 1, 0.1, 0, 0)   "},{"title":"Reset​","type":1,"pageTitle":"PID","url":"api/PID#Reset","content":"&lt;/&gt; PID:Reset() → () Resets the PID to a zero start state.  "},{"title":"Calculate​","type":1,"pageTitle":"PID","url":"api/PID#Calculate","content":"&lt;/&gt; PID:Calculate( setpoint: number,-- The desired point to reach input: number-- The current inputted value ) → output: number Calculates the new output based on the setpoint and input. For example, if the PID was being used for a car's throttle control where the throttle can be in the range of [0, 1], then the PID calculation might look like the following: local cruisePID = PID.new(0, 1, ...) local desiredSpeed = 50 RunService.Heartbeat:Connect(function() local throttle = cruisePID:Calculate(desiredSpeed, car.CurrentSpeed) car:SetThrottle(throttle) end)   "},{"title":"Debug​","type":1,"pageTitle":"PID","url":"api/PID#Debug","content":"&lt;/&gt; PID:Debug( name: string,-- Folder name parent: Instance? -- Folder parent ) → () Creates a folder that contains attributes that can be used to tune the PID during runtime within the explorer. Studio Only This will only create the folder in Studio. In a real game server, this function will do nothing.  "},{"title":"Destroy​","type":1,"pageTitle":"PID","url":"api/PID#Destroy","content":"&lt;/&gt; PID:Destroy() → () Destroys the PID. This is only necessary if calling PID:Debug. "},{"title":"Option","type":0,"sectionRef":"#","url":"api/Option","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Option","url":"api/Option#properties","content":" "},{"title":"None​","type":1,"pageTitle":"Option","url":"api/Option#None","content":"&lt;/&gt; Option.None: Option&lt;None&gt; Represents no value. "},{"title":"Functions​","type":1,"pageTitle":"Option","url":"api/Option#functions","content":" "},{"title":"Some​","type":1,"pageTitle":"Option","url":"api/Option#Some","content":"&lt;/&gt; Option.Some(value: T) → Option&lt;T&gt; Creates an Option instance with the given value. Throws an error if the given value is nil.  "},{"title":"Wrap​","type":1,"pageTitle":"Option","url":"api/Option#Wrap","content":"&lt;/&gt; Option.Wrap(value: T) → Option&lt;T&gt; | Option&lt;None&gt; Safely wraps the given value as an option. If the value is nil, returns Option.None, otherwise returns Option.Some(value).  "},{"title":"Is​","type":1,"pageTitle":"Option","url":"api/Option#Is","content":"&lt;/&gt; Option.Is(obj: any) → boolean Returns true if obj is an Option.  "},{"title":"Assert​","type":1,"pageTitle":"Option","url":"api/Option#Assert","content":"&lt;/&gt; Option.Assert(obj: any) → () Throws an error if obj is not an Option.  "},{"title":"Deserialize​","type":1,"pageTitle":"Option","url":"api/Option#Deserialize","content":"&lt;/&gt; Option.Deserialize(data: table) → Option Deserializes the data into an Option. This data should have come from the option:Serialize() method.  "},{"title":"Serialize​","type":1,"pageTitle":"Option","url":"api/Option#Serialize","content":"&lt;/&gt; Option:Serialize() → table Returns a serialized version of the option.  "},{"title":"Match​","type":1,"pageTitle":"Option","url":"api/Option#Match","content":"&lt;/&gt; Option:Match(matches: {Some: (value: any) → any,None: () → any}) → any Matches against the option. local opt = Option.Some(32) opt:Match { Some = function(num) print(&quot;Number&quot;, num) end, None = function() print(&quot;No value&quot;) end, }   "},{"title":"IsSome​","type":1,"pageTitle":"Option","url":"api/Option#IsSome","content":"&lt;/&gt; Option:IsSome() → boolean Returns true if the option has a value.  "},{"title":"IsNone​","type":1,"pageTitle":"Option","url":"api/Option#IsNone","content":"&lt;/&gt; Option:IsNone() → boolean Returns true if the option is None.  "},{"title":"Expect​","type":1,"pageTitle":"Option","url":"api/Option#Expect","content":"&lt;/&gt; Option:Expect(msg: string) → value: any Unwraps the value in the option, otherwise throws an error with msg as the error message. local opt = Option.Some(10) print(opt:Expect(&quot;No number&quot;)) -&gt; 10 print(Option.None:Expect(&quot;No number&quot;)) -- Throws an error &quot;No number&quot;   "},{"title":"ExpectNone​","type":1,"pageTitle":"Option","url":"api/Option#ExpectNone","content":"&lt;/&gt; Option:ExpectNone(msg: string) → () Throws an error with msg as the error message if the value is not None.  "},{"title":"Unwrap​","type":1,"pageTitle":"Option","url":"api/Option#Unwrap","content":"&lt;/&gt; Option:Unwrap() → value: any Returns the value in the option, or throws an error if the option is None.  "},{"title":"UnwrapOr​","type":1,"pageTitle":"Option","url":"api/Option#UnwrapOr","content":"&lt;/&gt; Option:UnwrapOr(default: any) → value: any If the option holds a value, returns the value. Otherwise, returns default.  "},{"title":"UnwrapOrElse​","type":1,"pageTitle":"Option","url":"api/Option#UnwrapOrElse","content":"&lt;/&gt; Option:UnwrapOrElse(defaultFn: () → any) → value: any If the option holds a value, returns the value. Otherwise, returns the result of the defaultFn function.  "},{"title":"And​","type":1,"pageTitle":"Option","url":"api/Option#And","content":"&lt;/&gt; Option:And(optionB: Option) → Option Returns optionB if the calling option has a value, otherwise returns None. local optionA = Option.Some(32) local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == optionB local optionA = Option.None local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == Option.None   "},{"title":"AndThen​","type":1,"pageTitle":"Option","url":"api/Option#AndThen","content":"&lt;/&gt; Option:AndThen(andThenFn: (value: any) → Option) → value: Option If the option holds a value, then the andThenFn function is called with the held value of the option, and then the resultant Option returned by the andThenFn is returned. Otherwise, None is returned. local optA = Option.Some(32) local optB = optA:AndThen(function(num) return Option.Some(num * 2) end) print(optB:Expect(&quot;Expected number&quot;)) --&gt; 64   "},{"title":"Or​","type":1,"pageTitle":"Option","url":"api/Option#Or","content":"&lt;/&gt; Option:Or(optionB: Option) → Option If caller has a value, returns itself. Otherwise, returns optionB.  "},{"title":"OrElse​","type":1,"pageTitle":"Option","url":"api/Option#OrElse","content":"&lt;/&gt; Option:OrElse(orElseFn: () → Option) → Option If caller has a value, returns itself. Otherwise, returns the option generated by the orElseFn function.  "},{"title":"XOr​","type":1,"pageTitle":"Option","url":"api/Option#XOr","content":"&lt;/&gt; Option:XOr(optionB: Option) → Option If both self and optionB have values or both don't have a value, then this returns None. Otherwise, it returns the option that does have a value.  "},{"title":"Filter​","type":1,"pageTitle":"Option","url":"api/Option#Filter","content":"&lt;/&gt; Option:Filter(predicate: (value: any) → boolean) → Option Returns self if this option has a value and the predicate returns `true. Otherwise, returns None.  "},{"title":"Contains​","type":1,"pageTitle":"Option","url":"api/Option#Contains","content":"&lt;/&gt; Option:Contains(value:: any) → boolean Returns true if this option contains value.  "},{"title":"__tostring​","type":1,"pageTitle":"Option","url":"api/Option#__tostring","content":"&lt;/&gt; Option:__tostring() → string Metamethod to transform the option into a string. local optA = Option.Some(64) local optB = Option.None print(optA) --&gt; Option&lt;number&gt; print(optB) --&gt; Option&lt;None&gt;   "},{"title":"__eq​","type":1,"pageTitle":"Option","url":"api/Option#__eq","content":"&lt;/&gt; Option:__eq() → boolean Metamethod to check equality between two options. Returns true if both options hold the same value or both options are None. local o1 = Option.Some(32) local o2 = Option.Some(32) local o3 = Option.Some(64) local o4 = Option.None local o5 = Option.None print(o1 == o2) --&gt; true print(o1 == o3) --&gt; false print(o1 == o4) --&gt; false print(o4 == o5) --&gt; true  "},{"title":"PreferredInput","type":0,"sectionRef":"#","url":"api/PreferredInput","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#types","content":" "},{"title":"InputType​","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#InputType","content":"Enum &lt;/&gt; interface InputType { MouseKeyboard: &quot;MouseKeyboard&quot;-- Prefer mouse and keyboard input Touch: &quot;MouseKeyboard&quot;-- Prefer touch input Gamepad: &quot;Gamepad&quot;-- Prefer gamepad input }  "},{"title":"Properties​","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#Changed","content":"Event &lt;/&gt; PreferredInput.Changed: Signal&lt;InputType&gt; Fired when the preferred InputType changes.  "},{"title":"InputType​","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#InputType","content":"This item is read only and cannot be modified. Read Only Enums &lt;/&gt; PreferredInput.InputType: InputType A table containing the InputType enum, e.g. Preferred.InputType.Gamepad.  "},{"title":"Current​","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#Current","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; PreferredInput.Current: InputType The current preferred InputType. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil }  "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#functions","content":" "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player , ...: any ) → nil-- The function to connect ) → Connection Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Fire​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player ,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the client.  "},{"title":"FireAll​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the clients.  "},{"title":"FireFilter​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player , argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)   "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object. "},{"title":"Ser","type":0,"sectionRef":"#","url":"api/Ser","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Ser","url":"api/Ser#properties","content":" "},{"title":"Classes​","type":1,"pageTitle":"Ser","url":"api/Ser#Classes","content":"&lt;/&gt; Ser.Classes: table A dictionary of classes along with a Serialize and Deserialize function. For instance, the default class added is the Option class, which looks like the following: Ser.Classes.Option = { Serialize = function(opt) return opt:Serialize() end; Deserialize = Option.Deserialize; } Add to this table in order to extend what classes are automatically serialized/deserialized. The Ser library checks every object's ClassName field in both serialized and deserialized data in order to map it to the correct function within the Classes table. "},{"title":"Functions​","type":1,"pageTitle":"Ser","url":"api/Ser#functions","content":" "},{"title":"SerializeArgs​","type":1,"pageTitle":"Ser","url":"api/Ser#SerializeArgs","content":"&lt;/&gt; Ser.SerializeArgs(...: any) → args: table Serializes the arguments and returns the serialized values in a table.  "},{"title":"SerializeArgsAndUnpack​","type":1,"pageTitle":"Ser","url":"api/Ser#SerializeArgsAndUnpack","content":"&lt;/&gt; Ser.SerializeArgsAndUnpack(...: any) → args: ...any Serializes the arguments and returns the serialized values.  "},{"title":"DeserializeArgs​","type":1,"pageTitle":"Ser","url":"api/Ser#DeserializeArgs","content":"&lt;/&gt; Ser.DeserializeArgs(...: any) → args: table Deserializes the arguments and returns the deserialized values in a table.  "},{"title":"DeserializeArgsAndUnpack​","type":1,"pageTitle":"Ser","url":"api/Ser#DeserializeArgsAndUnpack","content":"&lt;/&gt; Ser.DeserializeArgsAndUnpack(...: any) → args: table Deserializes the arguments and returns the deserialized values.  "},{"title":"Serialize​","type":1,"pageTitle":"Ser","url":"api/Ser#Serialize","content":"&lt;/&gt; Ser.Serialize(value: any) → any Serializes the given value.  "},{"title":"Deserialize​","type":1,"pageTitle":"Ser","url":"api/Ser#Deserialize","content":"&lt;/&gt; Ser.Deserialize(value: any) → any Deserializes the given value.  "},{"title":"UnpackArgs​","type":1,"pageTitle":"Ser","url":"api/Ser#UnpackArgs","content":"&lt;/&gt; Ser.UnpackArgs(value: any) → any Unpacks the arguments returned by either SerializeArgs or DeserializeArgs. "},{"title":"ServerComm","type":0,"sectionRef":"#","url":"api/ServerComm","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#types","content":" "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions. "},{"title":"Functions​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#new","content":"&lt;/&gt; ServerComm.new( parent: Instance , namespace: string? ) → ServerComm Constructs a ServerComm object. The namespace parameter is used in cases where more than one ServerComm object may be bound to the same object. Otherwise, a default namespace is used.  "},{"title":"BindFunction​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#BindFunction","content":"&lt;/&gt; ServerComm:BindFunction( name: string, fn: ( player: Player , ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired.  "},{"title":"WrapMethod​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#WrapMethod","content":"&lt;/&gt; ServerComm:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction    "},{"title":"CreateSignal​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#CreateSignal","content":"&lt;/&gt; ServerComm:CreateSignal( name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal   "},{"title":"Destroy​","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#Destroy","content":"&lt;/&gt; ServerComm:Destroy() → () Destroy the ServerComm object. "},{"title":"Signal","type":0,"sectionRef":"#","url":"api/Signal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: (...any) → nil) → Connection-- A connection to the signal Connects a function to the signal, which will be called anytime the signal is fired.  "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal.  "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"api/Signal#Fire","content":"&lt;/&gt; Signal:Fire( ...: any-- Arguments to pass to the connected functions ) → () Fire the signal, which will call all of the connected functions with the given arguments.  "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred( ...: any-- Arguments to pass to the connected functions ) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse.  "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any-- Arguments passed to the signal when it was fired Yields the current thread until the signal is fired, and returns the arguments fired from the signal.  "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. "},{"title":"Streamable","type":0,"sectionRef":"#","url":"api/Streamable","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Streamable","url":"api/Streamable#properties","content":" "},{"title":"Instance​","type":1,"pageTitle":"Streamable","url":"api/Streamable#Instance","content":"&lt;/&gt; Streamable.Instance: Instance  The current instance represented by the Streamable. If this is being observed, it will always exist. If not currently being observed, this will be nil. "},{"title":"Functions​","type":1,"pageTitle":"Streamable","url":"api/Streamable#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Streamable","url":"api/Streamable#new","content":"&lt;/&gt; Streamable.new( parent: Instance , childName: string ) → Streamable Constructs a Streamable that watches for a direct child of name childName within the parent Instance. Call Observe to observe the existence of the child within the parent.  "},{"title":"primary​","type":1,"pageTitle":"Streamable","url":"api/Streamable#primary","content":"&lt;/&gt; Streamable.primary(parent: Model ) → Streamable Constructs a streamable that watches for the PrimaryPart of the given parent Model.  "},{"title":"Observe​","type":1,"pageTitle":"Streamable","url":"api/Streamable#Observe","content":"&lt;/&gt; Streamable:Observe(handler: ( instance: Instance , trove: Trove ) → nil) → Connection Observes the instance. The handler is called anytime the instance comes into existence, and the trove given is cleaned up when the instance goes away. To stop observing, disconnect the returned connection.  "},{"title":"Destroy​","type":1,"pageTitle":"Streamable","url":"api/Streamable#Destroy","content":"&lt;/&gt; Streamable:Destroy() → () Destroys the Streamable. "},{"title":"StreamableUtil","type":0,"sectionRef":"#","url":"api/StreamableUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"StreamableUtil","url":"api/StreamableUtil#functions","content":" "},{"title":"Compound​","type":1,"pageTitle":"StreamableUtil","url":"api/StreamableUtil#Compound","content":"&lt;/&gt; StreamableUtil.Compound( streamables: {Streamable}, handler: ( {[child: string]: Instance }, trove: Trove ) → nil ) → Trove Creates a compound streamable around all the given streamables. The compound streamable's observer handler will be fired once all the given streamables are in existence, and will be cleaned up when any of the streamables disappear. local s1 = Streamable.new(workspace, &quot;Part1&quot;) local s2 = Streamable.new(workspace, &quot;Part2&quot;) local compoundTrove = StreamableUtil.Compound({S1 = s1, S2 = s2}, function(streamables, trove) local part1 = streamables.S1.Instance local part2 = streamables.S2.Instance trove:Add(function() print(&quot;Cleanup&quot;) end) end)  "},{"title":"Shake","type":0,"sectionRef":"#","url":"api/Shake","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Shake","url":"api/Shake#types","content":" "},{"title":"UpdateCallbackFn​","type":1,"pageTitle":"Shake","url":"api/Shake#UpdateCallbackFn","content":"&lt;/&gt; type UpdateCallbackFn = () → ( position: Vector3 , rotation: Vector3 , completed: boolean )  "},{"title":"Properties​","type":1,"pageTitle":"Shake","url":"api/Shake#properties","content":" "},{"title":"Amplitude​","type":1,"pageTitle":"Shake","url":"api/Shake#Amplitude","content":"&lt;/&gt; Shake.Amplitude: number Amplitude of the overall shake. For instance, an amplitude of 3 would mean the peak magnitude for the outputted shake vectors would be about 3. Defaults to 1.  "},{"title":"Frequency​","type":1,"pageTitle":"Shake","url":"api/Shake#Frequency","content":"&lt;/&gt; Shake.Frequency: number Frequency of the overall shake. This changes how slow or fast the shake occurs. Defaults to 1.  "},{"title":"FadeInTime​","type":1,"pageTitle":"Shake","url":"api/Shake#FadeInTime","content":"&lt;/&gt; Shake.FadeInTime: number How long it takes for the shake to fade in, measured in seconds. Defaults to 1.  "},{"title":"FadeOutTime​","type":1,"pageTitle":"Shake","url":"api/Shake#FadeOutTime","content":"&lt;/&gt; Shake.FadeOutTime: number How long it takes for the shake to fade out, measured in seconds. Defaults to 1.  "},{"title":"SustainTime​","type":1,"pageTitle":"Shake","url":"api/Shake#SustainTime","content":"&lt;/&gt; Shake.SustainTime: number How long it takes for the shake sustains itself after fading in and before fading out. To sustain a shake indefinitely, set Sustain to true, and call the StopSustain() method to stop the sustain and fade out the shake effect. Defaults to 0.  "},{"title":"Sustain​","type":1,"pageTitle":"Shake","url":"api/Shake#Sustain","content":"&lt;/&gt; Shake.Sustain: boolean If true, the shake will sustain itself indefinitely once it fades in. If StopSustain() is called, the sustain will end and the shake will fade out based on the FadeOutTime. Defaults to false.  "},{"title":"PositionInfluence​","type":1,"pageTitle":"Shake","url":"api/Shake#PositionInfluence","content":"&lt;/&gt; Shake.PositionInfluence: Vector3  This is similar to Amplitude but multiplies against each axis of the resultant shake vector, and only affects the position vector. Defaults to Vector3.one.  "},{"title":"RotationInfluence​","type":1,"pageTitle":"Shake","url":"api/Shake#RotationInfluence","content":"&lt;/&gt; Shake.RotationInfluence: Vector3  This is similar to Amplitude but multiplies against each axis of the resultant shake vector, and only affects the rotation vector. Defaults to Vector3.one.  "},{"title":"TimeFunction​","type":1,"pageTitle":"Shake","url":"api/Shake#TimeFunction","content":"&lt;/&gt; Shake.TimeFunction: () → number The function used to get the current time. This defaults totime during runtime, and os.clock otherwise. Usually this will not need to be set, but it can be optionally configured if desired. "},{"title":"Functions​","type":1,"pageTitle":"Shake","url":"api/Shake#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Shake","url":"api/Shake#new","content":"&lt;/&gt; Shake.new() → Shake Construct a new Shake instance.  "},{"title":"InverseSquare​","type":1,"pageTitle":"Shake","url":"api/Shake#InverseSquare","content":"&lt;/&gt; Shake.InverseSquare( vector: Vector3 , distance: number ) → Vector3  Apply an inverse square intensity multiplier to the given vector based on the distance away from some source. This can be used to simulate shake intensity based on the distance the shake is occurring from some source. For instance, if the shake is caused by an explosion in the game, the shake can be calculated as such: local function Explosion(positionOfExplosion: Vector3) local cam = workspace.CurrentCamera local renderPriority = Enum.RenderPriority.Last.Value local shake = Shake.new() -- Set shake properties here local function ExplosionShake(pos: Vector3, rot: Vector3) local distance = (cam.CFrame.Position - positionOfExplosion).Magnitude pos = Shake.InverseSquare(pos, distance) rot = Shake.InverseSquare(rot, distance) cam.CFrame *= CFrame.new(pos) * CFrame.Angles(rot.X, rot.Y, rot.Z) end shake:BindToRenderStep(&quot;ExplosionShake&quot;, renderPriority, ExplosionShake) end   "},{"title":"NextRenderName​","type":1,"pageTitle":"Shake","url":"api/Shake#NextRenderName","content":"&lt;/&gt; Shake.NextRenderName() → string Returns a unique render name for every call, which can be used with the BindToRenderStep method optionally. shake:BindToRenderStep(Shake.NextRenderName(), ...)   "},{"title":"Start​","type":1,"pageTitle":"Shake","url":"api/Shake#Start","content":"&lt;/&gt; Shake:Start() → () Start the shake effect. note This must be called before calling Update. As such, it should also be called once before or after calling OnSignal or BindToRenderStep methods.  "},{"title":"Stop​","type":1,"pageTitle":"Shake","url":"api/Shake#Stop","content":"&lt;/&gt; Shake:Stop() → () Stops the shake effect. If using OnSignal or BindToRenderStep, those bound functions will be disconnected/unbound. Stop is automatically called when the shake effect is completed or when the Destroy method is called.  "},{"title":"IsShaking​","type":1,"pageTitle":"Shake","url":"api/Shake#IsShaking","content":"&lt;/&gt; Shake:IsShaking() → boolean Returns true if the shake instance is currently running, otherwise returns false.  "},{"title":"StopSustain​","type":1,"pageTitle":"Shake","url":"api/Shake#StopSustain","content":"&lt;/&gt; Shake:StopSustain() → () Schedules a sustained shake to stop. This works by setting theSustain field to false and letting the shake effect fade out based on the FadeOutTime field.  "},{"title":"Update​","type":1,"pageTitle":"Shake","url":"api/Shake#Update","content":"&lt;/&gt; Shake:Update() → ( position: Vector3 , rotation: Vector3 , completed: boolean ) Calculates the current shake vector. This should be continuously called inside a loop, such as RunService.Heartbeat. Alternatively, OnSignal or BindToRenderStep can be used to automatically call this function. Returns a tuple of three values: position: Vector3 - Position shake offset rotation: Vector3 - Rotation shake offset completed: boolean - Flag indicating if the shake is finished local hb hb = RunService.Heartbeat:Connect(function() local offsetPosition, offsetRotation, isDone = shake:Update() if isDone then hb:Disconnect() end -- Use `offsetPosition` and `offsetRotation` here end)   "},{"title":"OnSignal​","type":1,"pageTitle":"Shake","url":"api/Shake#OnSignal","content":"&lt;/&gt; Shake:OnSignal( signal: Signal | RBXScriptSignal , callbackFn: UpdateCallbackFn ) → Connection | RBXScriptConnection  Bind the Update method to a signal. For instance, this can be used to connect to RunService.Heartbeat. All connections are cleaned up when the shake instance is stopped or destroyed. local function SomeShake(pos: Vector3, rot: Vector3, completed: boolean) -- Shake end shake:OnSignal(RunService.Heartbeat, SomeShake)   "},{"title":"BindToRenderStep​","type":1,"pageTitle":"Shake","url":"api/Shake#BindToRenderStep","content":"&lt;/&gt; Shake:BindToRenderStep( name: string,-- Name passed to RunService:BindToRenderStep priority: number,-- Priority passed to RunService:BindToRenderStep callbackFn: UpdateCallbackFn ) → () Bind the Update method to RenderStep. All bond functions are cleaned up when the shake instance is stopped or destroyed. local renderPriority = Enum.RenderPriority.Camera.Value local function SomeShake(pos: Vector3, rot: Vector3, completed: boolean) -- Shake end shake:BindToRenderStep(&quot;SomeShake&quot;, renderPriority, SomeShake)   "},{"title":"Clone​","type":1,"pageTitle":"Shake","url":"api/Shake#Clone","content":"&lt;/&gt; Shake:Clone() → Shake Creates a new shake with identical properties as this one. This does not clone over playing state, and thus the cloned instance will be in a stopped state. A use-case for using Clone would be to create a module with a list of shake presets. These presets can be cloned when desired for use. For instance, there might be presets for explosions, recoil, or earthquakes. -------------------------------------- -- Example preset module local ShakePresets = {} local explosion = Shake.new() -- Configure `explosion` shake here ShakePresets.Explosion = explosion return ShakePresets -------------------------------------- -- Use the module: local ShakePresets = require(somewhere.ShakePresets) local explosionShake = ShakePresets.Explosion:Clone()   "},{"title":"Destroy​","type":1,"pageTitle":"Shake","url":"api/Shake#Destroy","content":"&lt;/&gt; Shake:Destroy() → () Destroy the Shake instance. Will call Stop(). "},{"title":"Symbol","type":0,"sectionRef":"#","url":"api/Symbol","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Symbol","url":"api/Symbol#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Symbol","url":"api/Symbol#new","content":"&lt;/&gt; Symbol.new( id: any,-- Identifier for the symbol (usually a string) scope: Symbol?-- Optional symbol scope ) → boolean-- Returns true if the obj parameter is a Symbol Constructs a new symbol  "},{"title":"Is​","type":1,"pageTitle":"Symbol","url":"api/Symbol#Is","content":"&lt;/&gt; Symbol.Is( obj: any-- Anything ) → boolean-- Returns true if the obj parameter is a Symbol Checks if the given object is a Symbol.  "},{"title":"IsInScope​","type":1,"pageTitle":"Symbol","url":"api/Symbol#IsInScope","content":"&lt;/&gt; Symbol.IsInScope( obj: any,-- Anything scope: Symbol-- Scope symbol ) → boolean-- Returns true if the obj parameter is a Symbol and in the given scope Checks if the given object is a Symbol an in the given scope "},{"title":"TaskQueue","type":0,"sectionRef":"#","url":"api/TaskQueue","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TaskQueue","url":"api/TaskQueue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"TaskQueue","url":"api/TaskQueue#new","content":"&lt;/&gt; TaskQueue.new(onFlush: ({T}) → nil) → TaskQueue&lt;T&gt; Constructs a new TaskQueue.  "},{"title":"Add​","type":1,"pageTitle":"TaskQueue","url":"api/TaskQueue#Add","content":"&lt;/&gt; TaskQueue:Add(object: T) → () Add an object to the queue.  "},{"title":"Clear​","type":1,"pageTitle":"TaskQueue","url":"api/TaskQueue#Clear","content":"&lt;/&gt; TaskQueue:Clear() → () Clears the TaskQueue. This will clear any tasks that were scheduled to be flushed on the current execution frame. queue:Add(something1) queue:Add(something2) queue:Clear()   "},{"title":"Destroy​","type":1,"pageTitle":"TaskQueue","url":"api/TaskQueue#Destroy","content":"&lt;/&gt; TaskQueue:Destroy() → () Destroys the TaskQueue. Just an alias for Clear(). "},{"title":"Timer","type":0,"sectionRef":"#","url":"api/Timer","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Timer","url":"api/Timer#properties","content":" "},{"title":"Interval​","type":1,"pageTitle":"Timer","url":"api/Timer#Interval","content":"&lt;/&gt; Timer.Interval: number Interval at which the Tick event fires.  "},{"title":"UpdateSignal​","type":1,"pageTitle":"Timer","url":"api/Timer#UpdateSignal","content":"&lt;/&gt; Timer.UpdateSignal: RBXScriptSignal | Signal The signal which updates the timer internally.  "},{"title":"TimeFunction​","type":1,"pageTitle":"Timer","url":"api/Timer#TimeFunction","content":"&lt;/&gt; Timer.TimeFunction: () → number The function which gets the current time.  "},{"title":"AllowDrift​","type":1,"pageTitle":"Timer","url":"api/Timer#AllowDrift","content":"&lt;/&gt; Timer.AllowDrift: boolean Flag which indicates if the timer is allowed to drift. This is set to true by default. This flag must be set before calling Start or StartNow. This flag should only be set to false if it is necessary for drift to be eliminated.  "},{"title":"Tick​","type":1,"pageTitle":"Timer","url":"api/Timer#Tick","content":"&lt;/&gt; Timer.Tick: RBXScriptSignal | Signal The event which is fired every time the timer hits its interval. "},{"title":"Functions​","type":1,"pageTitle":"Timer","url":"api/Timer#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Timer","url":"api/Timer#new","content":"&lt;/&gt; Timer.new(interval: number) → Timer Creates a new timer.  "},{"title":"Simple​","type":1,"pageTitle":"Timer","url":"api/Timer#Simple","content":"&lt;/&gt; Timer.Simple( interval: number, callback: () → nil, startNow: boolean?, updateSignal: RBXScriptSignal? | Signal?, timeFunc: () → number ) → RBXScriptConnection  Creates a simplified timer which just fires off a callback function at the given interval.  "},{"title":"Is​","type":1,"pageTitle":"Timer","url":"api/Timer#Is","content":"&lt;/&gt; Timer.Is(obj: any) → boolean Returns true if the given object is a Timer.  "},{"title":"Start​","type":1,"pageTitle":"Timer","url":"api/Timer#Start","content":"&lt;/&gt; Timer:Start() → () Starts the timer.  "},{"title":"StartNow​","type":1,"pageTitle":"Timer","url":"api/Timer#StartNow","content":"&lt;/&gt; Timer:StartNow() → () Starts the timer and fires off the Tick event immediately.  "},{"title":"Stop​","type":1,"pageTitle":"Timer","url":"api/Timer#Stop","content":"&lt;/&gt; Timer:Stop() → () Stops the timer.  "},{"title":"Destroy​","type":1,"pageTitle":"Timer","url":"api/Timer#Destroy","content":"&lt;/&gt; Timer:Destroy() → () Destroys the timer. "},{"title":"TableUtil","type":0,"sectionRef":"#","url":"api/TableUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#functions","content":" "},{"title":"Copy​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Copy","content":"&lt;/&gt; TableUtil.Copy( tbl: table,-- Table to copy deep: boolean?-- Whether or not to perform a deep copy ) → table Creates a copy of the given table. By default, a shallow copy is performed. For deep copies, a second boolean argument must be passed to the function. No cyclical references Deep copies are not protected against cyclical references. Passing a table with cyclical references and the deep parameter set to true will result in a stack-overflow.  "},{"title":"Sync​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Sync","content":"&lt;/&gt; TableUtil.Sync( srcTbl: table,-- Source table templateTbl: table-- Template table ) → table Synchronizes the srcTbl based on the templateTbl. This will make sure that srcTbl has all of the same keys as templateTbl, including removing keys in srcTbl that are not present in templateTbl. This is a deep operation, so any nested tables will be synchronized as well. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, experience = 12} data = TableUtil.Sync(data, template) print(data) --&gt; {kills = 10, deaths = 0, xp = 0} Data Loss Warning This is a two-way sync, so the source table will have dataremoved that isn't found in the template table. This can be problematic if used for player data, where there might be dynamic data added that isn't in the template. For player data, use TableUtil.Reconcile instead.  "},{"title":"Reconcile​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Reconcile","content":"&lt;/&gt; TableUtil.Reconcile( source: table, template: table ) → table Performs a one-way sync on the source table against the template table. Any keys found in template that are not found in source will be added to source. This is useful for syncing player data against data template tables to ensure players have all the necessary keys, while maintaining existing keys that may no longer be in the template. This is a deep operation, so nested tables will also be properly reconciled. local template = {kills = 0, deaths = 0, xp = 0} local data = {kills = 10, abc = 20} local correctedData = TableUtil.Reconcile(data, template) print(correctedData) --&gt; {kills = 10, deaths = 0, xp = 0, abc = 30}   "},{"title":"SwapRemove​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#SwapRemove","content":"&lt;/&gt; TableUtil.SwapRemove( tbl: table,-- Array i: number-- Index ) → () Removes index i in the table by swapping the value at i with the last value in the array, and then trimming off the last value from the array. This allows removal of the value at i in O(1) time, but does not preserve array ordering. If a value needs to be removed from an array, but ordering of the array does not matter, using SwapRemove is always preferred over table.remove. In the following example, we remove &quot;B&quot; at index 2. SwapRemove does this by moving the last value &quot;E&quot; over top of &quot;B&quot;, and then trimming off &quot;E&quot; at the end of the array: local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} TableUtil.SwapRemove(t, 2) -- Remove &quot;B&quot; print(t) --&gt; {&quot;A&quot;, &quot;E&quot;, &quot;C&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"SwapRemoveFirstValue​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#SwapRemoveFirstValue","content":"&lt;/&gt; TableUtil.SwapRemoveFirstValue( tbl: table,-- Array v: any-- Value to find ) → number? Performs table.find(tbl, v) to find the index of the given value, and then performs TableUtil.SwapRemove on that index. local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} TableUtil.SwapRemoveFirstValue(t, &quot;C&quot;) print(t) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;E&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Map​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Map","content":"&lt;/&gt; TableUtil.Map( tbl: table, predicate: ( value: any, key: any, tbl: table ) → newValue: any ) → table Performs a map operation against the given table, which can be used to map new values based on the old values at given keys/indices. For example: local t = {A = 10, B = 20, C = 30} local t2 = TableUtil.Map(t, function(key, value) return value * 2 end) print(t2) --&gt; {A = 20, B = 40, C = 60}   "},{"title":"Filter​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Filter","content":"&lt;/&gt; TableUtil.Filter( tbl: table, predicate: ( value: any, key: any, tbl: table ) → keep: boolean ) → table Performs a filter operation against the given table, which can be used to filter out unwanted values from the table. For example: local t = {A = 10, B = 20, C = 30} local t2 = TableUtil.Filter(t, function(key, value) return value &gt; 15 end) print(t2) --&gt; {B = 40, C = 60}   "},{"title":"Reduce​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Reduce","content":"&lt;/&gt; TableUtil.Reduce( tbl: table, predicate: ( accumulator: any, value: any, index: any, tbl: table ) → result: any ) → table Performs a reduce operation against the given table, which can be used to reduce the table into a single value. This could be used to sum up a table or transform all the values into a compound value of any kind. For example: local t = {10, 20, 30, 40} local result = TableUtil.Reduce(t, function(accum, value) return accum + value end) print(result) --&gt; 100   "},{"title":"Assign​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Assign","content":"&lt;/&gt; TableUtil.Assign( target: table, ...: table ) → table Copies all values of the given tables into the target table. local t = {A = 10} local t2 = {B = 20} local t3 = {C = 30, D = 40} local newT = TableUtil.Assign(t, t2, t3) print(newT) --&gt; {A = 10, B = 20, C = 30, D = 40}   "},{"title":"Extend​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Extend","content":"&lt;/&gt; TableUtil.Extend( target: table, extension: table ) → table Extends the target array with the extension array. local t = {10, 20, 30} local t2 = {30, 40, 50} local tNew = TableUtil.Extend(t, t2) print(tNew) --&gt; {10, 20, 30, 30, 40, 50} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Reverse​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Reverse","content":"&lt;/&gt; TableUtil.Reverse(tbl: table) → table Reverses the array. local t = {1, 5, 10} local tReverse = TableUtil.Reverse(t) print(tReverse) --&gt; {10, 5, 1} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Shuffle​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Shuffle","content":"&lt;/&gt; TableUtil.Shuffle( tbl: table, rngOverride: Random? ) → table Shuffles the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local shuffled = TableUtil.Shuffle(t) print(shuffled) --&gt; e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Sample​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Sample","content":"&lt;/&gt; TableUtil.Sample( tbl: table, sampleSize: number, rngOverride: Random? ) → table Returns a random sample of the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local sample = TableUtil.Sample(t, 3) print(sample) --&gt; e.g. {6, 2, 5} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Flat​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Flat","content":"&lt;/&gt; TableUtil.Flat( tbl: table, depth: number? ) → table Returns a new table where all sub-arrays have been bubbled up to the top. The depth at which the scan is performed is dictated by the depth parameter, which is set to 1 by default. local t = {{10, 20}, {90, 100}, {30, 15}} local flat = TableUtil.Flat(t) print(flat) --&gt; {10, 20, 90, 100, 30, 15} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"FlatMap​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#FlatMap","content":"&lt;/&gt; TableUtil.FlatMap( tbl: table, predicate: ( key: any, value: any, tbl: table ) → newValue: any ) → table Calls TableUtil.Map on the given table and predicate, and then calls TableUtil.Flat on the result from the map operation. local t = {10, 20, 30} local result = TableUtil.FlatMap(t, function(value) return {value, value * 2} end) print(result) --&gt; {10, 20, 20, 40, 30, 60} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Keys​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Keys","content":"&lt;/&gt; TableUtil.Keys(tbl: table) → table Returns an array with all the keys in the table. local t = {A = 10, B = 20, C = 30} local keys = TableUtil.Keys(t) print(keys) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} Ordering The ordering of the keys is never guaranteed. If order is imperative, calltable.sort on the resulting keys array. local keys = TableUtil.Keys(t) table.sort(keys)   "},{"title":"Find​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Find","content":"&lt;/&gt; TableUtil.Find( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → ( value: any?, key: any? ) Performs a linear scan across the table and calls callback on each item in the array. Returns the value and key of the first pair in which the callback returns true. local t = { {Name = &quot;Bob&quot;, Age = 20}; {Name = &quot;Jill&quot;, Age = 30}; {Name = &quot;Ann&quot;, Age = 25}; } -- Find first person who has a name starting with J: local firstPersonWithJ = TableUtil.Find(t, function(person) return person.Name:sub(1, 1):lower() == &quot;j&quot; end) print(firstPersonWithJ) --&gt; {Name = &quot;Jill&quot;, Age = 30} Dictionary Ordering While Find can also be used with dictionaries, dictionary ordering is never guaranteed, and thus the result could be different if there are more than one possible matches given the data and callback function.  "},{"title":"Every​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Every","content":"&lt;/&gt; TableUtil.Every( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for every item in the table. local t = {10, 20, 40, 50, 60} local allAboveZero = TableUtil.Every(t, function(value) return value &gt; 0 end) print(&quot;All above zero:&quot;, allAboveZero) --&gt; All above zero: true   "},{"title":"Some​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Some","content":"&lt;/&gt; TableUtil.Some( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for at least one of the items in the table. local t = {10, 20, 40, 50, 60} local someBelowTwenty = TableUtil.Some(t, function(value) return value &lt; 20 end) print(&quot;Some below twenty:&quot;, someBelowTwenty) --&gt; Some below twenty: true   "},{"title":"Truncate​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Truncate","content":"&lt;/&gt; TableUtil.Truncate( tbl: table, length: number ) → table Returns a new table truncated to the length of length. local t = {10, 20, 30, 40, 50, 60, 70, 80} local tTruncated = TableUtil.Truncate(t, 3) print(tTruncated) --&gt; {10, 20, 30}   "},{"title":"Zip​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Zip","content":"&lt;/&gt; TableUtil.Zip(...: table) → ( iter: ( t: table, k: any ) → ( key: any?, values: table? ), tbl: table, startIndex: any? ) Returns an iterator that can scan through multiple tables at the same time side-by-side, matching against shared keys/indices. local t1 = {10, 20, 30, 40, 50} local t2 = {60, 70, 80, 90, 100} for key,values in TableUtil.Zip(t1, t2) do print(key, values) end --[[ Outputs: 1 {10, 60} 2 {20, 70} 3 {30, 80} 4 {40, 90} 5 {50, 100} --]]   "},{"title":"Lock​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Lock","content":"&lt;/&gt; TableUtil.Lock(tbl: table) → table Locks the table using table.freeze, as well as any nested tables within the given table. This will lock the whole deep structure of the table, disallowing any further modifications. local tbl = {xyz = {abc = 32}} tbl.xyz.abc = 28 -- Works fine TableUtil.Lock(tbl) tbl.xyz.abc = 64 -- Will throw an error (cannot modify readonly table)   "},{"title":"IsEmpty​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#IsEmpty","content":"&lt;/&gt; TableUtil.IsEmpty(tbl: table) → boolean Returns true if the given table is empty. This is simply performed by checking if next(tbl) is nil and works for both arrays and dictionaries. This is useful when needing to check if a table is empty but not knowing if it is an array or dictionary. TableUtil.IsEmpty({}) -- true TableUtil.IsEmpty({&quot;abc&quot;}) -- false TableUtil.IsEmpty({abc = 32}) -- false   "},{"title":"EncodeJSON​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#EncodeJSON","content":"&lt;/&gt; TableUtil.EncodeJSON(value: any) → string Proxy for HttpService:JSONEncode.  "},{"title":"DecodeJSON​","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#DecodeJSON","content":"&lt;/&gt; TableUtil.DecodeJSON(value: any) → string Proxy for HttpService:JSONDecode. "},{"title":"Touch","type":0,"sectionRef":"#","url":"api/Touch","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Touch","url":"api/Touch#properties","content":" "},{"title":"TouchTapInWorld​","type":1,"pageTitle":"Touch","url":"api/Touch#TouchTapInWorld","content":"Event &lt;/&gt; Touch.TouchTapInWorld: Signal&lt;( position: Vector2 , processed: boolean )&gt; Proxy for UserInputService.TouchTapInWorld.  "},{"title":"TouchPan​","type":1,"pageTitle":"Touch","url":"api/Touch#TouchPan","content":"Event &lt;/&gt; Touch.TouchPan: Signal&lt;( touchPositions: {Vector2 }, totalTranslation: Vector2 , velocity: Vector2 , state: Enum.UserInputState, processed: boolean )&gt; Proxy for UserInputService.TouchPan.  "},{"title":"TouchPinch​","type":1,"pageTitle":"Touch","url":"api/Touch#TouchPinch","content":"Event &lt;/&gt; Touch.TouchPinch: Signal&lt;( touchPositions: {Vector2 }, scale: number, velocity: Vector2 , state: Enum.UserInputState, processed: boolean )&gt; Proxy for UserInputService.TouchPinch. "},{"title":"Functions​","type":1,"pageTitle":"Touch","url":"api/Touch#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Touch","url":"api/Touch#new","content":"&lt;/&gt; Touch.new() → () Constructs a new Touch input capturer.  "},{"title":"Destroy​","type":1,"pageTitle":"Touch","url":"api/Touch#Destroy","content":"&lt;/&gt; Touch:Destroy() → () Destroys the Touch input capturer. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Wally Configuration​","type":1,"pageTitle":"Getting Started","url":"docs/intro#wally-configuration","content":"Once Wally is installed, run wally init on your project directory, and then add the various utility modules found here as dependencies. For example, the following could be a wally.toml file for a project that includes a few of these modules: [package] name = &quot;your_name/your_project&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] Signal = &quot;sleitnick/signal@^1&quot; TableUtil = &quot;sleitnick/table-util@^1&quot; Copy To install these dependencies, run wally install within your project. Wally will create a Package folder in your directory with the installed dependencies. "},{"title":"Rojo Configuration​","type":1,"pageTitle":"Getting Started","url":"docs/intro#rojo-configuration","content":"The Package folder created by Wally should be synced into Roblox Studio through your Rojo configuration. For instance, a Rojo configuration might have the following entry to sync the Packages folder into ReplicatedStorage: { &quot;name&quot;: &quot;rbx-util-example&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;Packages&quot;: { &quot;$path&quot;: &quot;Packages&quot; } } } } Copy "},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"docs/intro#usage-example","content":"The installed dependencies can now be used in scripts, such as the following: -- Reference folder with packages: local Packages = game:GetService(&quot;ReplicatedStorage&quot;).Packages -- Require the utility modules: local Signal = require(Packages.Signal) local TableUtil = require(Packages.TableUtil) -- Use the modules: local signal = Signal.new() signal:Connect(function(data) local randomizedData = TableUtil.Shuffle(data) print(randomizedData) end) signal:Fire({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) Copy "},{"title":"Trove","type":0,"sectionRef":"#","url":"api/Trove","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Trove","url":"api/Trove#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Trove","url":"api/Trove#new","content":"&lt;/&gt; Trove.new() → () Constructs a Trove object.  "},{"title":"Construct​","type":1,"pageTitle":"Trove","url":"api/Trove#Construct","content":"&lt;/&gt; Trove:Construct( class: table | (...any) → any, ...: any ) → any Constructs a new object from either the table or function given. If a table is given, the table's new function will be called with the given arguments. If a function is given, the function will be called with the given arguments. The result from either of the two options will be added to the trove. local Signal = require(somewhere.Signal) -- All of these are identical: local s = trove:Construct(Signal) local s = trove:Construct(Signal.new) local s = trove:Construct(function() return Signal.new() end) local s = trove:Add(Signal.new()) -- Even Roblox instances can be created: local part = trove:Construct(Instance, &quot;Part&quot;)   "},{"title":"Connect​","type":1,"pageTitle":"Trove","url":"api/Trove#Connect","content":"&lt;/&gt; Trove:Connect( signal: RBXScriptSignal , fn: (...: any) → any ) → RBXScriptConnection  Connects the function to the signal, adds the connection to the trove, and then returns the connection. trove:Connect(workspace.ChildAdded, function(instance) print(instance.Name .. &quot; added to workspace&quot;) end)   "},{"title":"BindToRenderStep​","type":1,"pageTitle":"Trove","url":"api/Trove#BindToRenderStep","content":"&lt;/&gt; Trove:BindToRenderStep( name: string, priority: number, fn: (dt: number) → nil ) → () Calls RunService:BindToRenderStep and registers a function in the trove that will call RunService:UnbindFromRenderStep on cleanup. trove:BindToRenderStep(&quot;Test&quot;, Enum.RenderPriority.Last.Value, function(dt) -- Do something end)   "},{"title":"Add​","type":1,"pageTitle":"Trove","url":"api/Trove#Add","content":"&lt;/&gt; Trove:Add( object: any,-- Object to track cleanupMethod: string?-- Optional cleanup name override ) → object: any Adds an object to the trove. Once the trove is cleaned or destroyed, the object will also be cleaned up. The object must be any of the following: Roblox instance (e.g. Part) RBXScriptConnection (e.g. workspace.ChildAdded:Connect(function() end)) Function Table with either a Destroy or Disconnect method Table with custom cleanupMethod name provided Returns the object added. -- Add a part to the trove, then destroy the trove, -- which will also destroy the part: local part = Instance.new(&quot;Part&quot;) trove:Add(part) trove:Destroy() -- Add a function to the trove: trove:Add(function() print(&quot;Cleanup!&quot;) end) trove:Destroy() -- Standard cleanup from table: local tbl = {} function tbl:Destroy() print(&quot;Cleanup&quot;) end trove:Add(tbl) -- Custom cleanup from table: local tbl = {} function tbl:DoSomething() print(&quot;Do something on cleanup&quot;) end trove:Add(tbl, &quot;DoSomething&quot;)   "},{"title":"Remove​","type":1,"pageTitle":"Trove","url":"api/Trove#Remove","content":"&lt;/&gt; Trove:Remove( object: any-- Object to remove ) → () Removes the object from the Trove and cleans it up. local part = Instance.new(&quot;Part&quot;) trove:Add(part) trove:Remove(part)   "},{"title":"Clean​","type":1,"pageTitle":"Trove","url":"api/Trove#Clean","content":"&lt;/&gt; Trove:Clean() → () Cleans up all objects in the trove. This is similar to calling Remove on each object within the trove.  "},{"title":"AttachToInstance​","type":1,"pageTitle":"Trove","url":"api/Trove#AttachToInstance","content":"&lt;/&gt; Trove:AttachToInstance(instance: Instance ) → RBXScriptConnection  Attaches the trove to a Roblox instance. Once this instance is removed from the game (parent or ancestor's parent set to nil), the trove will automatically clean up. caution Will throw an error if instance is not a descendant of the game hierarchy.  "},{"title":"Destroy​","type":1,"pageTitle":"Trove","url":"api/Trove#Destroy","content":"&lt;/&gt; Trove:Destroy() → () Destroys the Trove object. Forces Clean to run. "}]