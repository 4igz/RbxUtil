[{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#properties","content":" "},{"title":"Changed","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Changed","content":"&lt;/&gt; ClientRemoteProperty.Changed: Signal A signal which is fired anytime the value changes. The new value is passed to the connected functions. "},{"title":"Functions","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#functions","content":" "},{"title":"new","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#new","content":"&lt;/&gt; ClientRemoteProperty.new(instance: Instance) → ClientRemoteProperty Constructs a ClientRemoteProperty that wraps around the instance created by the server-side RemoteProperty.  "},{"title":"Destroy","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the ClientRemoteProperty  "},{"title":"Get","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → value: any Returns the value currently held. "},{"title":"ClientComm","type":0,"sectionRef":"#","url":"api/ClientComm","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#types","content":" "},{"title":"ClientMiddleware","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} Array of middleware functions.  "},{"title":"ClientMiddlewareFn","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) The middleware function takes the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware. "},{"title":"Functions","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#functions","content":" "},{"title":"new","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#new","content":"&lt;/&gt; ClientComm.new( parent: Instance, usePromise: boolean, namespace: string? ) → ClientComm Constructs a ClientComm object. If usePromise is set to true, then GetFunction will generate a function that returns a Promise that resolves with the server response. If set to false, the function will act like a normal call to a RemoteFunction and yield until the function responds.  "},{"title":"Destroy","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#Destroy","content":"&lt;/&gt; ClientComm:Destroy() → () Destroys the ClientComm object.  "},{"title":"GetFunction","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#GetFunction","content":"&lt;/&gt; ClientComm:GetFunction( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → (...: any) → any Generates a function on the matching RemoteFunction generated with ServerComm. The function can then be called to invoke the server. If this ClientComm object was created with the usePromise parameter set to true, then this generated function will return a Promise when called. -- Server-side: local serverComm = ServerComm.new(someParent) serverComm:BindFunction(&quot;MyFunction&quot;, function(msg) return msg:upper() end) -- Client-side: local clientComm = ClientComm.new(someParent) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) local uppercase = myFunc(&quot;hello world&quot;) print(uppercase) --&gt; HELLO WORLD -- Client-side, using promises: local clientComm = ClientComm.new(someParent, true) local myFunc = clientComm:GetFunction(&quot;MyFunction&quot;) myFunc(&quot;hi there&quot;):andThen(function(msg) print(msg) --&gt; HI THERE end):catch(function(err) print(&quot;Error:&quot;, err) end)   "},{"title":"GetSignal","type":1,"pageTitle":"ClientComm","url":"api/ClientComm#GetSignal","content":"&lt;/&gt; ClientComm:GetSignal( name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ) → ClientRemoteSignal Returns a new ClientRemoteSignal that mirrors the matching RemoteSignal created by ServerComm with the same matching name. "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#types","content":" "},{"title":"Connection","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil }  "},{"title":"Functions","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#functions","content":" "},{"title":"Connect","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(fn: (...: any) → any) → Connection Connects a function to the remote signal. The function will be called anytime the equivalent server-side RemoteSignal is fired at this specific client that created this client signal.  "},{"title":"Destroy","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the ClientRemoteSignal object.  "},{"title":"Fire","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire( ...: any-- Arguments to pass to the server ) → () Fires the equivalent server-side signal with the given arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the server. "},{"title":"Component","type":0,"sectionRef":"#","url":"api/Component","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Component","url":"api/Component#functions","content":" "},{"title":"Auto","type":1,"pageTitle":"Component","url":"api/Component#Auto","content":"&lt;/&gt; Component.Auto(parent: Instance) → RBXScriptConnection Scans all descendants of parent and loads any ModuleScripts found, then calls Component.new on those loaded modules. Each component module class must have a Tag string property to map it to the proper tag.  "},{"title":"FromTag","type":1,"pageTitle":"Component","url":"api/Component#FromTag","content":"&lt;/&gt; Component.FromTag(tag: string) → Component? Returns a component previously constructed by the tag. Returnsnil if no component is found.  "},{"title":"new","type":1,"pageTitle":"Component","url":"api/Component#new","content":"&lt;/&gt; Component.new( tag: string, class: table, renderPriority: number?, requireComponents: {string}? ) → Component Constructs a new component class.  "},{"title":"ObserveFromTag","type":1,"pageTitle":"Component","url":"api/Component#ObserveFromTag","content":"&lt;/&gt; Component.ObserveFromTag( tag: string, observer: ( component: Component, janitor: Jantior ) → nil ) → Janitor Observes the existence of a component.  "},{"title":"Destroy","type":1,"pageTitle":"Component","url":"api/Component#Destroy","content":"&lt;/&gt; Component:Destroy() → () Destroys the component class.  "},{"title":"Filter","type":1,"pageTitle":"Component","url":"api/Component#Filter","content":"&lt;/&gt; Component:Filter(filterFn: (value: componentInstance) → keep: boolean) → {componentInstance} Filters out all component instances based on the filterFn function predicate.  "},{"title":"GetAll","type":1,"pageTitle":"Component","url":"api/Component#GetAll","content":"&lt;/&gt; Component:GetAll() → {componentInstances} Returns an array of all component instances.  "},{"title":"GetFromID","type":1,"pageTitle":"Component","url":"api/Component#GetFromID","content":"&lt;/&gt; Component:GetFromID(id: string) → component? Returns a component instance from the given ID.  "},{"title":"GetFromInstance","type":1,"pageTitle":"Component","url":"api/Component#GetFromInstance","content":"&lt;/&gt; Component:GetFromInstance(instance: Instance) → component? Returns a component instance from the given Roblox instance.  "},{"title":"Observe","type":1,"pageTitle":"Component","url":"api/Component#Observe","content":"&lt;/&gt; Component:Observe( instance: Instance, observer: ( component: componentInstance, janitor: Janitor ) → nil ) → Janitor Observes the existence of a component instance on the given Roblox instance.  "},{"title":"WaitFor","type":1,"pageTitle":"Component","url":"api/Component#WaitFor","content":"&lt;/&gt; Component:WaitFor( instance: Instance, timeout: number? ) → Promise&lt;componentInstance&gt; Waits for a component instance to exist on the given Roblox instance. "},{"title":"Comm","type":0,"sectionRef":"#","url":"api/Comm","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"Comm","url":"api/Comm#types","content":" "},{"title":"Client","type":1,"pageTitle":"Comm","url":"api/Comm#Client","content":"&lt;/&gt; interface Client { GetFunction: ( parent: Instance, name: string, usePromise: boolean, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ): (...: any) → any GetSignal: ( parent: Instance, name: string, inboundMiddleware: ClientMiddleware?, outboundMiddleware: ClientMiddleware? ): ClientRemoteFunction } Client Comm  "},{"title":"Server","type":1,"pageTitle":"Comm","url":"api/Comm#Server","content":"&lt;/&gt; interface Server { BindFunction: ( parent: Instance, name: string, fn: FnBind, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ): RemoteFunction WrapMethod: ( parent: Instance, tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ): RemoteFunction CreateSignal: ( parent: Instance, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ): RemoteSignal } Server Comm "},{"title":"Properties","type":1,"pageTitle":"Comm","url":"api/Comm#properties","content":" "},{"title":"ClientComm","type":1,"pageTitle":"Comm","url":"api/Comm#ClientComm","content":"&lt;/&gt; Comm.ClientComm: ClientComm   "},{"title":"ServerComm","type":1,"pageTitle":"Comm","url":"api/Comm#ServerComm","content":"&lt;/&gt; Comm.ServerComm: ServerComm  "},{"title":"EnumList","type":0,"sectionRef":"#","url":"api/EnumList","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"EnumList","url":"api/EnumList#functions","content":" "},{"title":"new","type":1,"pageTitle":"EnumList","url":"api/EnumList#new","content":"&lt;/&gt; EnumList.new( name: string, enums: {string} ) → EnumList Constructs a new EnumList. local directions = EnumList.new(&quot;Directions&quot;, { &quot;Up&quot;, &quot;Down&quot;, &quot;Left&quot;, &quot;Right&quot;, }) local direction = directions.Up   "},{"title":"BelongsTo","type":1,"pageTitle":"EnumList","url":"api/EnumList#BelongsTo","content":"&lt;/&gt; EnumList:BelongsTo(obj: any) → boolean Returns true if obj belongs to the EnumList. "},{"title":"Input","type":0,"sectionRef":"#","url":"api/Input","content":"On this page Input The Input module provides access to various user input classes. PreferredInput Mouse Keyboard Touch local Input = require(packages.Input) local PreferredInput = Input.PreferredInput local Mouse = Input.Mouse local Keyboard = Input.Keyboard local Touch = Input.Touch ","keywords":""},{"title":"Keyboard","type":0,"sectionRef":"#","url":"api/Keyboard","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#properties","content":" "},{"title":"KeyDown","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#KeyDown","content":"Event &lt;/&gt; Keyboard.KeyDown: Signal&lt;Enum.KeyCode&gt; Fired when a key is pressed. keyboard.KeyDown:Connect(function(key: KeyCode) print(&quot;Key pressed&quot;, key) end)   "},{"title":"KeyUp","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#KeyUp","content":"Event &lt;/&gt; Keyboard.KeyUp: Signal&lt;Enum.KeyCode&gt; Fired when a key is released. keyboard.KeyUp:Connect(function(key: KeyCode) print(&quot;Key released&quot;, key) end)  "},{"title":"Functions","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#functions","content":" "},{"title":"new","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#new","content":"&lt;/&gt; Keyboard.new() → Keyboard Constructs a new keyboard input capturer. local keyboard = Keyboard.new()   "},{"title":"AreKeysDown","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#AreKeysDown","content":"&lt;/&gt; Keyboard:AreKeysDown( keyCodeOne: Enum.KeyCode, keyCodeTwo: Enum.KeyCode ) → areKeysDown: boolean Returns true if both keys are down. Useful for key combinations. local shiftA = keyboard:AreKeysDown(Enum.KeyCode.LeftShift, Enum.KeyCode.A) if shiftA then ... end   "},{"title":"Destroy","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#Destroy","content":"&lt;/&gt; Keyboard:Destroy() → () Destroy the keyboard input capturer.  "},{"title":"IsKeyDown","type":1,"pageTitle":"Keyboard","url":"api/Keyboard#IsKeyDown","content":"&lt;/&gt; Keyboard:IsKeyDown(keyCode: Enum.KeyCode) → isDown: boolean Returns true if the key is down. local w = keyboard:IsKeyDown(Enum.KeyCode.W) if w then ... end  "},{"title":"Loader","type":0,"sectionRef":"#","url":"api/Loader","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Loader","url":"api/Loader#functions","content":" "},{"title":"LoadChildren","type":1,"pageTitle":"Loader","url":"api/Loader#LoadChildren","content":"&lt;/&gt; Loader.LoadChildren( parent: Instance-- Parent to scan ) → {ModuleScript}-- Array of required modules Requires all children ModuleScripts  "},{"title":"LoadDescendants","type":1,"pageTitle":"Loader","url":"api/Loader#LoadDescendants","content":"&lt;/&gt; Loader.LoadDescendants( parent: Instance-- Parent to scan ) → {ModuleScript}-- Array of required modules Requires all descendant ModuleScripts "},{"title":"Mouse","type":0,"sectionRef":"#","url":"api/Mouse","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Mouse","url":"api/Mouse#properties","content":" "},{"title":"LeftDown","type":1,"pageTitle":"Mouse","url":"api/Mouse#LeftDown","content":"Event &lt;/&gt; Mouse.LeftDown: Signal   "},{"title":"LeftUp","type":1,"pageTitle":"Mouse","url":"api/Mouse#LeftUp","content":"Event &lt;/&gt; Mouse.LeftUp: Signal   "},{"title":"RightDown","type":1,"pageTitle":"Mouse","url":"api/Mouse#RightDown","content":"Event &lt;/&gt; Mouse.RightDown: Signal   "},{"title":"RightUp","type":1,"pageTitle":"Mouse","url":"api/Mouse#RightUp","content":"Event &lt;/&gt; Mouse.RightUp: Signal   "},{"title":"Scrolled","type":1,"pageTitle":"Mouse","url":"api/Mouse#Scrolled","content":"Event &lt;/&gt; Mouse.Scrolled: Signal&lt;number&gt; mouse.Scrolled:Connect(function(scrollAmount) ... end)  "},{"title":"Functions","type":1,"pageTitle":"Mouse","url":"api/Mouse#functions","content":" "},{"title":"new","type":1,"pageTitle":"Mouse","url":"api/Mouse#new","content":"&lt;/&gt; Mouse.new() → Mouse Constructs a new mouse input capturer. local mouse = Mouse.new()   "},{"title":"Destroy","type":1,"pageTitle":"Mouse","url":"api/Mouse#Destroy","content":"&lt;/&gt; Mouse:Destroy() → () Destroys the mouse.  "},{"title":"GetDelta","type":1,"pageTitle":"Mouse","url":"api/Mouse#GetDelta","content":"&lt;/&gt; Mouse:GetDelta() → deltaScreenPosition: Vector2  Only When Mouse Locked Getting the mouse delta is only intended for when the mouse is locked. If the mouse is not locked, this will return a zero Vector2. The mouse can be locked using the mouse:Lock() and mouse:LockCenter() method.  "},{"title":"GetPosition","type":1,"pageTitle":"Mouse","url":"api/Mouse#GetPosition","content":"&lt;/&gt; Mouse:GetPosition() → screenPosition: Vector2 Gets the 2D mouse position on the screen.  "},{"title":"GetRay","type":1,"pageTitle":"Mouse","url":"api/Mouse#GetRay","content":"&lt;/&gt; Mouse:GetRay(overridePos: Vector2?) → viewportMouseRay: Ray Returns the viewport point ray for the mouse at the current mouse position (or the override position if provided).  "},{"title":"IsLeftDown","type":1,"pageTitle":"Mouse","url":"api/Mouse#IsLeftDown","content":"&lt;/&gt; Mouse:IsLeftDown() → isLeftDown: boolean   "},{"title":"IsRightDown","type":1,"pageTitle":"Mouse","url":"api/Mouse#IsRightDown","content":"&lt;/&gt; Mouse:IsRightDown() → isRightDown: boolean   "},{"title":"Lock","type":1,"pageTitle":"Mouse","url":"api/Mouse#Lock","content":"&lt;/&gt; Mouse:Lock() → () Locks the mouse in its current position on screen. Call mouse:Unlock() to unlock the mouse. Must explicitly unlock Be sure to explicitly call mouse:Unlock() before cleaning up the mouse. The Destroy method does not unlock the mouse since there is no way to guarantee who &quot;owns&quot; the mouse lock.  "},{"title":"LockCenter","type":1,"pageTitle":"Mouse","url":"api/Mouse#LockCenter","content":"&lt;/&gt; Mouse:LockCenter() → () Locks the mouse in the center of the screen. Call mouse:Unlock() to unlock the mouse. Must explicitly unlock See cautionary in Lock method above.  "},{"title":"Raycast","type":1,"pageTitle":"Mouse","url":"api/Mouse#Raycast","content":"&lt;/&gt; Mouse:Raycast( raycastParams: RaycastParams, distance: number?, overridePos: Vector2? ) → result: RaycastResult? Performs a raycast operation out from the mouse position (or theoverridePos if provided) into world space. The ray will go distance studs forward (or 1000 studs if not provided). Returns the RaycastResult if something was hit, else returns nil.  "},{"title":"Unlock","type":1,"pageTitle":"Mouse","url":"api/Mouse#Unlock","content":"&lt;/&gt; Mouse:Unlock() → () Unlocks the mouse. "},{"title":"PID","type":0,"sectionRef":"#","url":"api/PID","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"PID","url":"api/PID#properties","content":" "},{"title":"POnE","type":1,"pageTitle":"PID","url":"api/PID#POnE","content":"&lt;/&gt; PID.POnE: boolean POnE stands for &quot;Proportional on Error&quot;. Set to true by default. true: The PID applies the proportional calculation on the error. false: The PID applies the proportional calculation on the measurement. Setting this value to false may help the PID move smoother and help elimiate overshoot. local pid = PID.new(...) pid.POnE = true|false  "},{"title":"Functions","type":1,"pageTitle":"PID","url":"api/PID#functions","content":" "},{"title":"new","type":1,"pageTitle":"PID","url":"api/PID#new","content":"&lt;/&gt; PID.new( min: number,-- Minimum value the PID can output max: number,-- Maximum value the PID can output kp: number,-- Proportional coefficient ki: number,-- Integral coefficient kd: number-- Derivative coefficient ) → PID Constructs a new PID. local pid = PID.new(0, 1, 0.1, 0, 0)   "},{"title":"Calculate","type":1,"pageTitle":"PID","url":"api/PID#Calculate","content":"&lt;/&gt; PID:Calculate( setpoint: number,-- The desired point to reach input: number-- The current inputted value ) → output: number Calculates the new output based on the setpoint and input. For example, if the PID was being used for a car's throttle control where the throttle can be in the range of [0, 1], then the PID calculation might look like the following: local cruisePID = PID.new(0, 1, ...) local desiredSpeed = 50 RunService.Heartbeat:Connect(function() local throttle = cruisePID:Calculate(desiredSpeed, car.CurrentSpeed) car:SetThrottle(throttle) end)   "},{"title":"Debug","type":1,"pageTitle":"PID","url":"api/PID#Debug","content":"&lt;/&gt; PID:Debug( name: string,-- Folder name parent: Instance?-- Folder parent ) → () Creates a folder that contains attributes that can be used to tune the PID during runtime within the explorer. Studio Only This will only create the folder in Studio. In a real game server, this function will do nothing.  "},{"title":"Destroy","type":1,"pageTitle":"PID","url":"api/PID#Destroy","content":"&lt;/&gt; PID:Destroy() → () Destroys the PID. This is only necessary if calling PID:Debug.  "},{"title":"Reset","type":1,"pageTitle":"PID","url":"api/PID#Reset","content":"&lt;/&gt; PID:Reset() → () Resets the PID to a zero start state. "},{"title":"PreferredInput","type":0,"sectionRef":"#","url":"api/PreferredInput","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#types","content":" "},{"title":"InputType","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#InputType","content":"Enum &lt;/&gt; interface InputType { MouseKeyboard: &quot;MouseKeyboard&quot;-- Prefer mouse and keyboard input Touch: &quot;MouseKeyboard&quot;-- Prefer touch input Gamepad: &quot;Gamepad&quot;-- Prefer gamepad input }  "},{"title":"Properties","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#properties","content":" "},{"title":"Changed","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#Changed","content":"Event &lt;/&gt; PreferredInput.Changed: Signal&lt;InputType&gt; Fired when the preferred InputType changes.  "},{"title":"Current","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#Current","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; PreferredInput.Current: InputType The current preferred InputType.  "},{"title":"InputType","type":1,"pageTitle":"PreferredInput","url":"api/PreferredInput#InputType","content":"This item is read only and cannot be modified. Read Only Enums &lt;/&gt; PreferredInput.InputType: InputType A table containing the InputType enum, e.g. Preferred.InputType.Gamepad. "},{"title":"Remote","type":0,"sectionRef":"#","url":"api/Remote","content":"On this page Remote The Remote module provides access to various remote communication classes. RemoteSignal RemoteProperty ClientRemoteSignal ClientRemoteProperty local Remote = require(packages.Remote) local RemoteSignal = Remote.RemoteSignal local RemoteProperty = Remote.RemoteProperty local ClientRemoteSignal = Remote.ClientRemoteSignal local ClientRemoteProperty = Remote.ClientRemoteProperty ","keywords":""},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"api/RemoteProperty","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#functions","content":" "},{"title":"Is","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Is","content":"&lt;/&gt; RemoteProperty.Is(object: any) → boolean Returns true if object is a RemoteProperty.  "},{"title":"new","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#new","content":"&lt;/&gt; RemoteProperty.new( value: any, overrideClass: string? ) → RemoteProperty Constructs a new RemoteProperty.  "},{"title":"Destroy","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the RemoteProperty.  "},{"title":"Get","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → value: any Returns the current value held by the RemoteProperty.  "},{"title":"Replicate","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Replicate","content":"&lt;/&gt; RemoteProperty:Replicate() → () Forces the value to be replicated. This is only necessary when the value is a table, because the RemoteProperty does not know when changes to the table are made. Other value types are automatically replicated when changed.  "},{"title":"Set","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the value. This value is immediately replicated to all clients. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"api/RemoteSignal","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#types","content":" "},{"title":"Connection","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Connection","content":"&lt;/&gt; interface Connection { Disconnect: () → nil }  "},{"title":"Functions","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#functions","content":" "},{"title":"Connect","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect( fn: ( player: Player, ...: any ) → nil-- The function to connect ) → Connection Connect a function to the signal. Anytime a matching ClientRemoteSignal on a client fires, the connected function will be invoked with the arguments passed by the client.  "},{"title":"Destroy","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the RemoteSignal object.  "},{"title":"Fire","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Fire","content":"&lt;/&gt; RemoteSignal:Fire( player: Player,-- The target client ...: any-- Arguments passed to the client ) → () Fires the signal at the specified client with any arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the client.  "},{"title":"FireAll","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireAll","content":"&lt;/&gt; RemoteSignal:FireAll(...: any) → () Fires the signal at all clients with any arguments. Outbound Middleware All arguments pass through any outbound middleware before being sent to the clients.  "},{"title":"FireFilter","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireFilter","content":"&lt;/&gt; RemoteSignal:FireFilter( predicate: ( player: Player, argsFromFire: ... ) → boolean, ...: any-- Arguments to pass to the clients (and to the predicate) ) → () Fires the signal at any clients that pass the predicate function test. This can be used to fire signals with much more control logic. Outbound Middleware All arguments pass through any outbound middleware before being sent to the clients. Predicate Before Middleware The arguments sent to the predicate are sent before getting transformed by any middleware. -- Fire signal to players of the same team: remoteSignal:FireFilter(function(player) return player.Team.Name == &quot;Best Team&quot; end)  "},{"title":"Option","type":0,"sectionRef":"#","url":"api/Option","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Option","url":"api/Option#properties","content":" "},{"title":"None","type":1,"pageTitle":"Option","url":"api/Option#None","content":"&lt;/&gt; Option.None: Option&lt;None&gt; Represents no value. "},{"title":"Functions","type":1,"pageTitle":"Option","url":"api/Option#functions","content":" "},{"title":"Assert","type":1,"pageTitle":"Option","url":"api/Option#Assert","content":"&lt;/&gt; Option.Assert(obj: any) → () Throws an error if obj is not an Option.  "},{"title":"Deserialize","type":1,"pageTitle":"Option","url":"api/Option#Deserialize","content":"&lt;/&gt; Option.Deserialize(data: table) → Option Deserializes the data into an Option. This data should have come from the option:Serialize() method.  "},{"title":"Is","type":1,"pageTitle":"Option","url":"api/Option#Is","content":"&lt;/&gt; Option.Is(obj: any) → boolean Returns true if obj is an Option.  "},{"title":"Some","type":1,"pageTitle":"Option","url":"api/Option#Some","content":"&lt;/&gt; Option.Some(value: T) → Option&lt;T&gt; Creates an Option instance with the given value. Throws an error if the given value is nil.  "},{"title":"Wrap","type":1,"pageTitle":"Option","url":"api/Option#Wrap","content":"&lt;/&gt; Option.Wrap(value: T) → Option&lt;T&gt; | Option&lt;None&gt; Safely wraps the given value as an option. If the value is nil, returns Option.None, otherwise returns Option.Some(value).  "},{"title":"__eq","type":1,"pageTitle":"Option","url":"api/Option#__eq","content":"&lt;/&gt; Option:__eq() → boolean Metamethod to check equality between two options. Returns true if both options hold the same value or both options are None. local o1 = Option.Some(32) local o2 = Option.Some(32) local o3 = Option.Some(64) local o4 = Option.None local o5 = Option.None print(o1 == o2) --&gt; true print(o1 == o3) --&gt; false print(o1 == o4) --&gt; false print(o4 == o5) --&gt; true   "},{"title":"__tostring","type":1,"pageTitle":"Option","url":"api/Option#__tostring","content":"&lt;/&gt; Option:__tostring() → string Metamethod to transform the option into a string. local optA = Option.Some(64) local optB = Option.None print(optA) --&gt; Option&lt;number&gt; print(optB) --&gt; Option&lt;None&gt;   "},{"title":"And","type":1,"pageTitle":"Option","url":"api/Option#And","content":"&lt;/&gt; Option:And(optionB: Option) → Option Returns optionB if the calling option has a value, otherwise returns None. local optionA = Option.Some(32) local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == optionB local optionA = Option.None local optionB = Option.Some(64) local opt = optionA:And(optionB) -- opt == Option.None   "},{"title":"AndThen","type":1,"pageTitle":"Option","url":"api/Option#AndThen","content":"&lt;/&gt; Option:AndThen(andThenFn: (value: any) → Option) → value: Option If the option holds a value, then the andThenFn function is called with the held value of the option, and then the resultant Option returned by the andThenFn is returned. Otherwise, None is returned. local optA = Option.Some(32) local optB = optA:AndThen(function(num) return Option.Some(num * 2) end) print(optB:Expect(&quot;Expected number&quot;)) --&gt; 64   "},{"title":"Contains","type":1,"pageTitle":"Option","url":"api/Option#Contains","content":"&lt;/&gt; Option:Contains(value:: any) → boolean Returns true if this option contains value.  "},{"title":"Expect","type":1,"pageTitle":"Option","url":"api/Option#Expect","content":"&lt;/&gt; Option:Expect(msg: string) → value: any Unwraps the value in the option, otherwise throws an error with msg as the error message. local opt = Option.Some(10) print(opt:Expect(&quot;No number&quot;)) -&gt; 10 print(Option.None:Expect(&quot;No number&quot;)) -- Throws an error &quot;No number&quot;   "},{"title":"ExpectNone","type":1,"pageTitle":"Option","url":"api/Option#ExpectNone","content":"&lt;/&gt; Option:ExpectNone(msg: string) → () Throws an error with msg as the error message if the value is not None.  "},{"title":"Filter","type":1,"pageTitle":"Option","url":"api/Option#Filter","content":"&lt;/&gt; Option:Filter(predicate: (value: any) → boolean) → Option Returns self if this option has a value and the predicate returns `true. Otherwise, returns None.  "},{"title":"IsNone","type":1,"pageTitle":"Option","url":"api/Option#IsNone","content":"&lt;/&gt; Option:IsNone() → boolean Returns true if the option is None.  "},{"title":"IsSome","type":1,"pageTitle":"Option","url":"api/Option#IsSome","content":"&lt;/&gt; Option:IsSome() → boolean Returns true if the option has a value.  "},{"title":"Match","type":1,"pageTitle":"Option","url":"api/Option#Match","content":"&lt;/&gt; Option:Match(matches: {Some: (value: any) → any,None: () → any}) → any Matches against the option. local opt = Option.Some(32) opt:Match { Some = function(num) print(&quot;Number&quot;, num) end, None = function() print(&quot;No value&quot;) end, }   "},{"title":"Or","type":1,"pageTitle":"Option","url":"api/Option#Or","content":"&lt;/&gt; Option:Or(optionB: Option) → Option If caller has a value, returns itself. Otherwise, returns optionB.  "},{"title":"OrElse","type":1,"pageTitle":"Option","url":"api/Option#OrElse","content":"&lt;/&gt; Option:OrElse(orElseFn: () → Option) → Option If caller has a value, returns itself. Otherwise, returns the option generated by the orElseFn function.  "},{"title":"Serialize","type":1,"pageTitle":"Option","url":"api/Option#Serialize","content":"&lt;/&gt; Option:Serialize() → table Returns a serialized version of the option.  "},{"title":"Unwrap","type":1,"pageTitle":"Option","url":"api/Option#Unwrap","content":"&lt;/&gt; Option:Unwrap() → value: any Returns the value in the option, or throws an error if the option is None.  "},{"title":"UnwrapOr","type":1,"pageTitle":"Option","url":"api/Option#UnwrapOr","content":"&lt;/&gt; Option:UnwrapOr(default: any) → value: any If the option holds a value, returns the value. Otherwise, returns default.  "},{"title":"UnwrapOrElse","type":1,"pageTitle":"Option","url":"api/Option#UnwrapOrElse","content":"&lt;/&gt; Option:UnwrapOrElse(defaultFn: () → any) → value: any If the option holds a value, returns the value. Otherwise, returns the result of the defaultFn function.  "},{"title":"XOr","type":1,"pageTitle":"Option","url":"api/Option#XOr","content":"&lt;/&gt; Option:XOr(optionB: Option) → Option If both self and optionB have values or both don't have a value, then this returns None. Otherwise, it returns the option that does have a value. "},{"title":"Ser","type":0,"sectionRef":"#","url":"api/Ser","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Ser","url":"api/Ser#properties","content":" "},{"title":"Classes","type":1,"pageTitle":"Ser","url":"api/Ser#Classes","content":"&lt;/&gt; Ser.Classes: table A dictionary of classes along with a Serialize and Deserialize function. For instance, the default class added is the Option class, which looks like the following: Ser.Classes.Option = { Serialize = function(opt) return opt:Serialize() end; Deserialize = Option.Deserialize; } Add to this table in order to extend what classes are automatically serialized/deserialized. The Ser library checks every object's ClassName field in both serialized and deserialized data in order to map it to the correct function within the Classes table. "},{"title":"Functions","type":1,"pageTitle":"Ser","url":"api/Ser#functions","content":" "},{"title":"Deserialize","type":1,"pageTitle":"Ser","url":"api/Ser#Deserialize","content":"&lt;/&gt; Ser.Deserialize(value: any) → any Deserializes the given value.  "},{"title":"DeserializeArgs","type":1,"pageTitle":"Ser","url":"api/Ser#DeserializeArgs","content":"&lt;/&gt; Ser.DeserializeArgs(...: any) → args: table Deserializes the arguments and returns the deserialized values in a table.  "},{"title":"DeserializeArgsAndUnpack","type":1,"pageTitle":"Ser","url":"api/Ser#DeserializeArgsAndUnpack","content":"&lt;/&gt; Ser.DeserializeArgsAndUnpack(...: any) → args: table Deserializes the arguments and returns the deserialized values.  "},{"title":"Serialize","type":1,"pageTitle":"Ser","url":"api/Ser#Serialize","content":"&lt;/&gt; Ser.Serialize(value: any) → any Serializes the given value.  "},{"title":"SerializeArgs","type":1,"pageTitle":"Ser","url":"api/Ser#SerializeArgs","content":"&lt;/&gt; Ser.SerializeArgs(...: any) → args: table Serializes the arguments and returns the serialized values in a table.  "},{"title":"SerializeArgsAndUnpack","type":1,"pageTitle":"Ser","url":"api/Ser#SerializeArgsAndUnpack","content":"&lt;/&gt; Ser.SerializeArgsAndUnpack(...: any) → args: ...any Serializes the arguments and returns the serialized values.  "},{"title":"UnpackArgs","type":1,"pageTitle":"Ser","url":"api/Ser#UnpackArgs","content":"&lt;/&gt; Ser.UnpackArgs(value: any) → any Unpacks the arguments returned by either SerializeArgs or DeserializeArgs. "},{"title":"ServerComm","type":0,"sectionRef":"#","url":"api/ServerComm","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#types","content":" "},{"title":"ServerMiddleware","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} Array of middleware functions.  "},{"title":"ServerMiddlewareFn","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player, args: {any} ) → ( shouldContinue: boolean, ...: any ) The middleware function takes the client player and the arguments (as a table array), and should return true|false to indicate if the process should continue. If returning false, the optional varargs after the false are used as the new return values to whatever was calling the middleware. "},{"title":"Functions","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#functions","content":" "},{"title":"new","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#new","content":"&lt;/&gt; ServerComm.new( parent: Instance, namespace: string? ) → ServerComm Constructs a ServerComm object. The namespace parameter is used in cases where more than one ServerComm object may be bound to the same object. Otherwise, a default namespace is used.  "},{"title":"BindFunction","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#BindFunction","content":"&lt;/&gt; ServerComm:BindFunction( name: string, fn: ( player: Player, ...: any ) → ...: any, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction Creates a RemoteFunction and binds the given function to it. Inbound and outbound middleware can be applied if desired.  "},{"title":"CreateSignal","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#CreateSignal","content":"&lt;/&gt; ServerComm:CreateSignal( name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteSignal   "},{"title":"Destroy","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#Destroy","content":"&lt;/&gt; ServerComm:Destroy() → () Destroy the ServerComm object.  "},{"title":"WrapMethod","type":1,"pageTitle":"ServerComm","url":"api/ServerComm#WrapMethod","content":"&lt;/&gt; ServerComm:WrapMethod( tbl: table, name: string, inboundMiddleware: ServerMiddleware?, outboundMiddleware: ServerMiddleware? ) → RemoteFunction  "},{"title":"Streamable","type":0,"sectionRef":"#","url":"api/Streamable","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Streamable","url":"api/Streamable#properties","content":" "},{"title":"Instance","type":1,"pageTitle":"Streamable","url":"api/Streamable#Instance","content":"&lt;/&gt; Streamable.Instance: Instance The current instance represented by the Streamable. If this is being observed, it will always exist. If not currently being observed, this will be nil. "},{"title":"Functions","type":1,"pageTitle":"Streamable","url":"api/Streamable#functions","content":" "},{"title":"Destroy","type":1,"pageTitle":"Streamable","url":"api/Streamable#Destroy","content":"&lt;/&gt; Streamable:Destroy() → () Destroys the Streamable.  "},{"title":"Observe","type":1,"pageTitle":"Streamable","url":"api/Streamable#Observe","content":"&lt;/&gt; Streamable:Observe(handler: ( instance: Instance, janitor: Janitor ) → nil) → Connection Observes the instance. The handler is called anytime the instance comes into existence, and the janitor given is cleaned up when the instance goes away. To stop observing, disconnect the returned connection. "},{"title":"Signal","type":0,"sectionRef":"#","url":"api/Signal","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Signal","url":"api/Signal#functions","content":" "},{"title":"Is","type":1,"pageTitle":"Signal","url":"api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  "},{"title":"new","type":1,"pageTitle":"Signal","url":"api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  "},{"title":"Wrap","type":1,"pageTitle":"Signal","url":"api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal-- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Connect","type":1,"pageTitle":"Signal","url":"api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: (...any) → nil) → Connection-- A connection to the signal Connects a function to the signal, which will be called anytime the signal is fired.  "},{"title":"Destroy","type":1,"pageTitle":"Signal","url":"api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal.  "},{"title":"DisconnectAll","type":1,"pageTitle":"Signal","url":"api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal.  "},{"title":"Fire","type":1,"pageTitle":"Signal","url":"api/Signal#Fire","content":"&lt;/&gt; Signal:Fire( ...: any-- Arguments to pass to the connected functions ) → () Fire the signal, which will call all of the connected functions with the given arguments.  "},{"title":"FireDeferred","type":1,"pageTitle":"Signal","url":"api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred( ...: any-- Arguments to pass to the connected functions ) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse.  "},{"title":"Wait","type":1,"pageTitle":"Signal","url":"api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any-- Arguments passed to the signal when it was fired Yields the current thread until the signal is fired, and returns the arguments fired from the signal. "},{"title":"StreamableUtil","type":0,"sectionRef":"#","url":"api/StreamableUtil","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"StreamableUtil","url":"api/StreamableUtil#functions","content":" "},{"title":"Compound","type":1,"pageTitle":"StreamableUtil","url":"api/StreamableUtil#Compound","content":"&lt;/&gt; StreamableUtil.Compound( streamables: {Streamable}, handler: ( {[child: string]: Instance}, janitor: Janitor ) → nil ) → Janitor Creates a compound streamable around all the given streamables. The compound streamable's observer handler will be fired once all the given streamables are in existence, and will be cleaned up when any of the streamables disappear. local s1 = Streamable.new(workspace, &quot;Part1&quot;) local s2 = Streamable.new(workspace, &quot;Part2&quot;) local compoundJanitor = StreamableUtil.Compound({S1 = s1, S2 = s2}, function(streamables, janitor) local part1 = streamables.S1.Instance local part2 = streamables.S2.Instance janitor:Add(function() print(&quot;Cleanup&quot;) end) end)  "},{"title":"Symbol","type":0,"sectionRef":"#","url":"api/Symbol","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Symbol","url":"api/Symbol#functions","content":" "},{"title":"Is","type":1,"pageTitle":"Symbol","url":"api/Symbol#Is","content":"&lt;/&gt; Symbol.Is( obj: any-- Anything ) → boolean-- Returns true if the obj parameter is a Symbol Checks if the given object is a Symbol.  "},{"title":"IsInScope","type":1,"pageTitle":"Symbol","url":"api/Symbol#IsInScope","content":"&lt;/&gt; Symbol.IsInScope( obj: any,-- Anything scope: Symbol-- Scope symbol ) → boolean-- Returns true if the obj parameter is a Symbol and in the given scope Checks if the given object is a Symbol an in the given scope  "},{"title":"new","type":1,"pageTitle":"Symbol","url":"api/Symbol#new","content":"&lt;/&gt; Symbol.new( id: any,-- Identifier for the symbol (usually a string) scope: Symbol?-- Optional symbol scope ) → boolean-- Returns true if the obj parameter is a Symbol Constructs a new symbol "},{"title":"Timer","type":0,"sectionRef":"#","url":"api/Timer","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Timer","url":"api/Timer#properties","content":" "},{"title":"AllowDrift","type":1,"pageTitle":"Timer","url":"api/Timer#AllowDrift","content":"&lt;/&gt; Timer.AllowDrift: boolean Flag which indicates if the timer is allowed to drift. This is set to true by default. This flag must be set before calling Start or StartNow. This flag should only be set to false if it is necessary for drift to be eliminated.  "},{"title":"Interval","type":1,"pageTitle":"Timer","url":"api/Timer#Interval","content":"&lt;/&gt; Timer.Interval: number Interval at which the Tick event fires.  "},{"title":"Tick","type":1,"pageTitle":"Timer","url":"api/Timer#Tick","content":"&lt;/&gt; Timer.Tick: RBXScriptSignal | Signal The event which is fired every time the timer hits its interval.  "},{"title":"TimeFunction","type":1,"pageTitle":"Timer","url":"api/Timer#TimeFunction","content":"&lt;/&gt; Timer.TimeFunction: () → number The function which gets the current time.  "},{"title":"UpdateSignal","type":1,"pageTitle":"Timer","url":"api/Timer#UpdateSignal","content":"&lt;/&gt; Timer.UpdateSignal: RBXScriptSignal | Signal The signal which updates the timer internally. "},{"title":"Functions","type":1,"pageTitle":"Timer","url":"api/Timer#functions","content":" "},{"title":"Is","type":1,"pageTitle":"Timer","url":"api/Timer#Is","content":"&lt;/&gt; Timer.Is(obj: any) → boolean Returns true if the given object is a Timer.  "},{"title":"new","type":1,"pageTitle":"Timer","url":"api/Timer#new","content":"&lt;/&gt; Timer.new(interval: number) → Timer Creates a new timer.  "},{"title":"Simple","type":1,"pageTitle":"Timer","url":"api/Timer#Simple","content":"&lt;/&gt; Timer.Simple( interval: number, callback: () → nil, startNow: boolean?, updateSignal: RBXScriptSignal? | Signal?, timeFunc: () → number ) → RBXScriptConnection Creates a simplified timer which just fires off a callback function at the given interval.  "},{"title":"Destroy","type":1,"pageTitle":"Timer","url":"api/Timer#Destroy","content":"&lt;/&gt; Timer:Destroy() → () Destroys the timer.  "},{"title":"Start","type":1,"pageTitle":"Timer","url":"api/Timer#Start","content":"&lt;/&gt; Timer:Start() → () Starts the timer.  "},{"title":"StartNow","type":1,"pageTitle":"Timer","url":"api/Timer#StartNow","content":"&lt;/&gt; Timer:StartNow() → () Starts the timer and fires off the Tick event immediately.  "},{"title":"Stop","type":1,"pageTitle":"Timer","url":"api/Timer#Stop","content":"&lt;/&gt; Timer:Stop() → () Stops the timer. "},{"title":"Touch","type":0,"sectionRef":"#","url":"api/Touch","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"Touch","url":"api/Touch#properties","content":" "},{"title":"TouchPan","type":1,"pageTitle":"Touch","url":"api/Touch#TouchPan","content":"Event &lt;/&gt; Touch.TouchPan: Signal&lt;( touchPositions: {Vector2}, totalTranslation: Vector2, velocity: Vector2, state: Enum.UserInputState, processed: boolean )&gt; Proxy for UserInputService.TouchPan.  "},{"title":"TouchPinch","type":1,"pageTitle":"Touch","url":"api/Touch#TouchPinch","content":"Event &lt;/&gt; Touch.TouchPinch: Signal&lt;( touchPositions: {Vector2}, scale: number, velocity: Vector2, state: Enum.UserInputState, processed: boolean )&gt; Proxy for UserInputService.TouchPinch.  "},{"title":"TouchTapInWorld","type":1,"pageTitle":"Touch","url":"api/Touch#TouchTapInWorld","content":"Event &lt;/&gt; Touch.TouchTapInWorld: Signal&lt;( position: Vector2, processed: boolean )&gt; Proxy for UserInputService.TouchTapInWorld. "},{"title":"Functions","type":1,"pageTitle":"Touch","url":"api/Touch#functions","content":" "},{"title":"new","type":1,"pageTitle":"Touch","url":"api/Touch#new","content":"&lt;/&gt; Touch.new() → () Constructs a new Touch input capturer.  "},{"title":"Destroy","type":1,"pageTitle":"Touch","url":"api/Touch#Destroy","content":"&lt;/&gt; Touch:Destroy() → () Destroys the Touch input capturer. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Wally Configuration","type":1,"pageTitle":"Getting Started","url":"docs/intro#wally-configuration","content":"Once Wally is installed, run wally init on your project directory, and then add the various utility modules found here as dependencies. For example, the following could be a wally.toml file for a project that includes a few of these modules: [package]name = &quot;your_name/your_project&quot;version = &quot;0.1.0&quot;registry = &quot;https://github.com/UpliftGames/wally-index&quot;realm = &quot;shared&quot; [dependencies]Signal = &quot;sleitnick/signal@^1.0&quot;TableUtil = &quot;slietnick/table-util@^1.0&quot; Copy To install these dependencies, run wally install within your project. Wally will create a Package folder in your directory with the installed dependencies. "},{"title":"Rojo Configuration","type":1,"pageTitle":"Getting Started","url":"docs/intro#rojo-configuration","content":"The Package folder created by Wally should be synced into Roblox Studio through your Rojo configuration. For instance, a Rojo configuration might have the following entry to sync the Packages folder into ReplicatedStorage: { &quot;name&quot;: &quot;rbx-util-example&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;Packages&quot;: { &quot;$path&quot;: &quot;Packages&quot; } } }} Copy "},{"title":"Usage Example","type":1,"pageTitle":"Getting Started","url":"docs/intro#usage-example","content":"The installed dependencies can now be used in scripts, such as the following: -- Reference folder with packages:local Packages = game:GetService(&quot;ReplicatedStorage&quot;).Packages -- Require the utility modules:local Signal = require(Packages.Signal)local TableUtil = require(Packages.TableUtil) -- Use the modules:local signal = Signal.new()signal:Connect(function(data) local randomizedData = TableUtil.Shuffle(data) print(randomizedData)end)signal:Fire({&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}) Copy "},{"title":"TableUtil","type":0,"sectionRef":"#","url":"api/TableUtil","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#functions","content":" "},{"title":"Assign","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Assign","content":"&lt;/&gt; TableUtil.Assign( target: table, ...: table ) → table Copies all values of the given tables into the target table. local t = {A = 10} local t2 = {B = 20} local t3 = {C = 30, D = 40} local newT = TableUtil.Assign(t, t2, t3) print(newT) --&gt; {A = 10, B = 20, C = 30, D = 40}   "},{"title":"Copy","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Copy","content":"&lt;/&gt; TableUtil.Copy( tbl: table,-- Table to copy deep: boolean?-- Whether or not to perform a deep copy ) → table Creates a copy of the given table. By default, a shallow copy is performed. For deep copies, a second boolean argument must be passed to the function. No cyclical references Deep copies are not protected against cyclical references. Passing a table with cyclical references and the deep parameter set to true will result in a stack-overflow.  "},{"title":"DecodeJSON","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#DecodeJSON","content":"&lt;/&gt; TableUtil.DecodeJSON(value: any) → string Proxy for HttpService:JSONDecode.  "},{"title":"EncodeJSON","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#EncodeJSON","content":"&lt;/&gt; TableUtil.EncodeJSON(value: any) → string Proxy for HttpService:JSONEncode.  "},{"title":"Every","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Every","content":"&lt;/&gt; TableUtil.Every( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for every item in the table. local t = {10, 20, 40, 50, 60} local allAboveZero = TableUtil.Every(t, function(value) return value &gt; 0 end) print(&quot;All above zero:&quot;, allAboveZero) --&gt; All above zero: true   "},{"title":"Extend","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Extend","content":"&lt;/&gt; TableUtil.Extend( target: table, extension: table ) → table Extends the target array with the extension array. local t = {10, 20, 30} local t2 = {30, 40, 50} local tNew = TableUtil.Extend(t, t2) print(tNew) --&gt; {10, 20, 30, 30, 40, 50} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Filter","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Filter","content":"&lt;/&gt; TableUtil.Filter( tbl: table, predicate: ( value: any, key: any, tbl: table ) → keep: boolean ) → table Performs a filter operation against the given table, which can be used to filter out unwanted values from the table. For example: local t = {A = 10, B = 20, C = 30} local t2 = TableUtil.Filter(t, function(key, value) return value &gt; 15 end) print(t2) --&gt; {B = 40, C = 60}   "},{"title":"Find","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Find","content":"&lt;/&gt; TableUtil.Find( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → ( value: any?, key: any? ) Performs a linear scan across the table and calls callback on each item in the array. Returns the value and key of the first pair in which the callback returns true. local t = { {Name = &quot;Bob&quot;, Age = 20}; {Name = &quot;Jill&quot;, Age = 30}; {Name = &quot;Ann&quot;, Age = 25}; } -- Find first person who has a name starting with J: local firstPersonWithJ = TableUtil.Find(t, function(person) return person.Name:sub(1, 1):lower() == &quot;j&quot; end) print(firstPersonWithJ) --&gt; {Name = &quot;Jill&quot;, Age = 30} Dictionary Ordering While Find can also be used with dictionaries, dictionary ordering is never guaranteed, and thus the result could be different if there are more than one possible matches given the data and callback function.  "},{"title":"Flat","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Flat","content":"&lt;/&gt; TableUtil.Flat( tbl: table, depth: number? ) → table Returns a new table where all sub-arrays have been bubbled up to the top. The depth at which the scan is performed is dictated by the depth parameter, which is set to 1 by default. local t = {{10, 20}, {90, 100}, {30, 15}} local flat = TableUtil.Flat(t) print(flat) --&gt; {10, 20, 90, 100, 30, 15} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"FlatMap","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#FlatMap","content":"&lt;/&gt; TableUtil.FlatMap( tbl: table, predicate: ( key: any, value: any, tbl: table ) → newValue: any ) → table Calls TableUtil.Map on the given table and predicate, and then calls TableUtil.Flat on the result from the map operation. local t = {10, 20, 30} local result = TableUtil.FlatMap(t, function(value) return {value, value * 2} end) print(result) --&gt; {10, 20, 20, 40, 30, 60} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"IsEmpty","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#IsEmpty","content":"&lt;/&gt; TableUtil.IsEmpty(tbl: table) → boolean Returns true if the given table is empty. This is simply performed by checking if next(tbl) is nil and works for both arrays and dictionaries. This is useful when needing to check if a table is empty but not knowing if it is an array or dictionary.  "},{"title":"Keys","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Keys","content":"&lt;/&gt; TableUtil.Keys(tbl: table) → table Returns an array with all the keys in the table. local t = {A = 10, B = 20, C = 30} local keys = TableUtil.Keys(t) print(keys) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} Ordering The ordering of the keys is never guaranteed. If order is imperative, calltable.sort on the resulting keys array. local keys = TableUtil.Keys(t) table.sort(keys)   "},{"title":"Map","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Map","content":"&lt;/&gt; TableUtil.Map( tbl: table, predicate: ( value: any, key: any, tbl: table ) → newValue: any ) → table Performs a map operation against the given table, which can be used to map new values based on the old values at given keys/indices. For example: local t = {A = 10, B = 20, C = 30} local t2 = TableUtil.Map(t, function(key, value) return value * 2 end) print(t2) --&gt; {A = 20, B = 40, C = 60}   "},{"title":"Reduce","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Reduce","content":"&lt;/&gt; TableUtil.Reduce( tbl: table, predicate: ( accumulator: any, value: any, index: any, tbl: table ) → result: any ) → table Performs a reduce operation against the given table, which can be used to reduce the table into a single value. This could be used to sum up a table or transform all the values into a compound value of any kind. For example: local t = {10, 20, 30, 40} local result = TableUtil.Filter(t, function(accum, value) return accum + value end) print(result) --&gt; 100   "},{"title":"Reverse","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Reverse","content":"&lt;/&gt; TableUtil.Reverse(tbl: table) → table Reverses the array. local t = {1, 5, 10} local tReverse = TableUtil.Reverse(t) print(tReverse) --&gt; {10, 5, 1} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Sample","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Sample","content":"&lt;/&gt; TableUtil.Sample( tbl: table, sampleSize: number, rngOverride: Random? ) → table Returns a random sample of the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local sample = TableUtil.Sample(t, 3) print(sample) --&gt; e.g. {6, 2, 5} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Shuffle","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Shuffle","content":"&lt;/&gt; TableUtil.Shuffle( tbl: table, rngOverride: Random? ) → table Shuffles the table. local t = {1, 2, 3, 4, 5, 6, 7, 8, 9} local shuffled = TableUtil.Shuffle(t) print(shuffled) --&gt; e.g. {9, 4, 6, 7, 3, 1, 5, 8, 2} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Some","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Some","content":"&lt;/&gt; TableUtil.Some( tbl: table, callback: ( value: any, index: any, tbl: table ) → boolean ) → boolean Returns true if the callback also returns true for at least one of the items in the table. local t = {10, 20, 40, 50, 60} local someBelowTwenty = TableUtil.Some(t, function(value) return value &lt; 20 end) print(&quot;Some below twenty:&quot;, someBelowTwenty) --&gt; Some below twenty: true   "},{"title":"SwapRemove","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#SwapRemove","content":"&lt;/&gt; TableUtil.SwapRemove( tbl: table,-- Array i: number-- Index ) → () Removes index i in the table by swapping the value at i with the last value in the array, and then trimming off the last value from the array. This allows removal of the value at i in O(1) time, but does not preserve array ordering. If a value needs to be removed from an array, but ordering of the array does not matter, using SwapRemove is always preferred over table.remove. In the following example, we remove &quot;B&quot; at index 2. SwapRemove does this by moving the last value &quot;E&quot; over top of &quot;B&quot;, and then trimming off &quot;E&quot; at the end of the array: local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} TableUtil.SwapRemove(t, 2) -- Remove &quot;B&quot; print(t) --&gt; {&quot;A&quot;, &quot;E&quot;, &quot;C&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"SwapRemoveFirstValue","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#SwapRemoveFirstValue","content":"&lt;/&gt; TableUtil.SwapRemoveFirstValue( tbl: table,-- Array v: any-- Value to find ) → number? Performs table.find(tbl, v) to find the index of the given value, and then performs TableUtil.SwapRemove on that index. local t = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;} TableUtil.SwapRemoveFirstValue(t, &quot;C&quot;) print(t) --&gt; {&quot;A&quot;, &quot;B&quot;, &quot;E&quot;, &quot;D&quot;} Arrays only This function works on arrays, but not dictionaries.  "},{"title":"Sync","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Sync","content":"&lt;/&gt; TableUtil.Sync( srcTbl: table,-- Source table templateTbl: table-- Template table ) → table Synchronizes the srcTbl based on the templateTbl. This will make sure that srcTbl has all of the same keys as templateTbl, including removing keys in srcTbl that are not present in templateTbl.  "},{"title":"Truncate","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Truncate","content":"&lt;/&gt; TableUtil.Truncate( tbl: table, length: number ) → table Returns a new table truncated to the length of length. local t = {10, 20, 30, 40, 50, 60, 70, 80} local tTruncated = TableUtil.Truncate(t, 3) print(tTruncated) --&gt; {10, 20, 30}   "},{"title":"Zip","type":1,"pageTitle":"TableUtil","url":"api/TableUtil#Zip","content":"&lt;/&gt; TableUtil.Zip(...: table) → ( iter: ( t: table, k: any ) → ( key: any?, values: table? ), tbl: table, startIndex: any? ) Returns an iterator that can scan through multiple tables at the same time side-by-side, matching against shared keys/indices. local t1 = {10, 20, 30, 40, 50} local t2 = {60, 70, 80, 90, 100} for key,values in TableUtil.Zip(t1, t2) do print(key, values) end --[[ Outputs: 1 {10, 60} 2 {20, 70} 3 {30, 80} 4 {40, 90} 5 {50, 100} --]]  "}]