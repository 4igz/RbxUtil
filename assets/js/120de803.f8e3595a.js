"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1124],{98217:function(n){n.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new Signal","params":[],"returns":[{"desc":"","lua_type":"Signal"}],"function_type":"static","source":{"line":149,"path":"modules/signal/init.lua"}},{"name":"Wrap","desc":"Constructs a new Signal that wraps around an RBXScriptSignal.\\n\\n\\nFor example:\\n```lua\\nlocal signal = Signal.Wrap(workspace.ChildAdded)\\nsignal:Connect(function(part) print(part.Name .. \\" added\\") end)\\nInstance.new(\\"Part\\").Parent = workspace\\n```","params":[{"name":"rbxScriptSignal","desc":"Existing RBXScriptSignal to wrap","lua_type":"RBXScriptSignal"}],"returns":[{"desc":"","lua_type":"Signal"}],"function_type":"static","source":{"line":171,"path":"modules/signal/init.lua"}},{"name":"Is","desc":"Checks if the given object is a Signal.","params":[{"name":"obj","desc":"Object to check","lua_type":"any"}],"returns":[{"desc":"`true` if the object is a Signal.","lua_type":"boolean"}],"function_type":"static","source":{"line":187,"path":"modules/signal/init.lua"}},{"name":"Connect","desc":"Connects a function to the signal, which will be called anytime the signal is fired.\\n```lua\\nsignal:Connect(function(msg, num)\\n\\tprint(msg, num)\\nend)\\n\\nsignal:Fire(\\"Hello\\", 25)\\n```","params":[{"name":"fn","desc":"","lua_type":"ConnectionFn"}],"returns":[{"desc":"","lua_type":"SignalConnection"}],"function_type":"method","source":{"line":205,"path":"modules/signal/init.lua"}},{"name":"DisconnectAll","desc":"Disconnects all connections from the signal.\\n```lua\\nsignal:DisconnectAll()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":236,"path":"modules/signal/init.lua"}},{"name":"Fire","desc":"Fire the signal, which will call all of the connected functions with the given arguments.\\n```lua\\nsignal:Fire(\\"Hello\\")\\n\\n-- Any number of arguments can be fired:\\nsignal:Fire(\\"Hello\\", 32, {Test = \\"Test\\"}, true)\\n```","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":261,"path":"modules/signal/init.lua"}},{"name":"FireDeferred","desc":"Same as `Fire`, but uses `task.defer` internally & doesn\'t take advantage of thread reuse.\\n```lua\\nsignal:FireDeferred(\\"Hello\\")\\n```","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":283,"path":"modules/signal/init.lua"}},{"name":"Wait","desc":"Yields the current thread until the signal is fired, and returns the arguments fired from the signal.\\n```lua\\ntask.spawn(function()\\n\\tlocal msg, num = signal:Wait()\\n\\tprint(msg, num) --\x3e \\"Hello\\", 32\\nend)\\nsignal:Fire(\\"Hello\\", 32)\\n```","params":[],"returns":[{"desc":"","lua_type":"... any"}],"function_type":"method","yields":true,"source":{"line":305,"path":"modules/signal/init.lua"}},{"name":"Destroy","desc":"Cleans up the signal.\\n\\nTechnically, this is only necessary if the signal is created using\\n`Signal.Wrap`. Connections should be properly GC\'d once the signal\\nis no longer referenced anywhere. However, it is still good practice\\nto include ways to strictly clean up resources. Calling `Destroy`\\non a signal will also disconnect all connections immediately.\\n```lua\\nsignal:Destroy()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":328,"path":"modules/signal/init.lua"}}],"properties":[],"types":[{"name":"SignalConnection","desc":"Represents a connection to a signal.\\n```lua\\nlocal connection = signal:Connect(function() end)\\nprint(connection.Connected) --\x3e true\\nconnection:Disconnect()\\nprint(connection.Connected) --\x3e false\\n```","fields":[{"name":"Connected","lua_type":"boolean","desc":""},{"name":"Disconnect","lua_type":"(SignalConnection) -> ()","desc":""}],"source":{"line":68,"path":"modules/signal/init.lua"}},{"name":"ConnectionFn","desc":"A function connected to a signal.","lua_type":"(...any) -> ()","source":{"line":124,"path":"modules/signal/init.lua"}}],"name":"Signal","desc":"Signals allow events to be dispatched and handled.\\n\\nFor example:\\n```lua\\nlocal signal = Signal.new()\\n\\nsignal:Connect(function(msg)\\n\\tprint(\\"Got message:\\", msg)\\nend)\\n\\nsignal:Fire(\\"Hello world!\\")\\n```","source":{"line":141,"path":"modules/signal/init.lua"}}')}}]);