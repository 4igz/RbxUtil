"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[124],{98217:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new Signal","params":[],"returns":[{"desc":"","lua_type":"Signal"}],"function_type":"static","source":{"line":127,"path":"packages/signal/init.lua"}},{"name":"Wrap","desc":"Constructs a new Signal that wraps around an RBXScriptSignal.\\n\\n\\nFor example:\\n```lua\\nlocal signal = Signal.Wrap(workspace.ChildAdded)\\nsignal:Connect(function(part) print(part.Name .. \\" added\\") end)\\nInstance.new(\\"Part\\").Parent = workspace\\n```","params":[{"name":"rbxScriptSignal","desc":"Existing RBXScriptSignal to wrap","lua_type":"RBXScriptSignal"}],"returns":[{"desc":"","lua_type":"Signal"}],"function_type":"static","source":{"line":149,"path":"packages/signal/init.lua"}},{"name":"Is","desc":"Checks if the given object is a Signal.","params":[{"name":"obj","desc":"Object to check","lua_type":"any"}],"returns":[{"desc":"`true` if the object is a Signal.","lua_type":"boolean"}],"function_type":"static","source":{"line":165,"path":"packages/signal/init.lua"}},{"name":"Connect","desc":"Connects a function to the signal, which will be called anytime the signal is fired.","params":[{"name":"fn","desc":"","lua_type":"(...any) -> nil"}],"returns":[{"desc":"A connection to the signal","lua_type":"Connection"}],"function_type":"method","source":{"line":176,"path":"packages/signal/init.lua"}},{"name":"DisconnectAll","desc":"Disconnects all connections from the signal.","params":[],"returns":[],"function_type":"method","source":{"line":204,"path":"packages/signal/init.lua"}},{"name":"Fire","desc":"Fire the signal, which will call all of the connected functions with the given arguments.","params":[{"name":"...","desc":"Arguments to pass to the connected functions","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":218,"path":"packages/signal/init.lua"}},{"name":"FireDeferred","desc":"Same as `Fire`, but uses `task.defer` internally & doesn\'t take advantage of thread reuse.","params":[{"name":"...","desc":"Arguments to pass to the connected functions","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":237,"path":"packages/signal/init.lua"}},{"name":"Wait","desc":"Yields the current thread until the signal is fired, and returns the arguments fired from the signal.","params":[],"returns":[{"desc":"Arguments passed to the signal when it was fired","lua_type":"... any"}],"function_type":"method","yields":true,"source":{"line":252,"path":"packages/signal/init.lua"}},{"name":"Destroy","desc":"Cleans up the signal.","params":[],"returns":[],"function_type":"method","source":{"line":266,"path":"packages/signal/init.lua"}}],"properties":[],"types":[],"name":"Signal","desc":"Signals allow events to be dispatched and handled.\\n\\nFor example:\\n```lua\\nlocal signal = Signal.new()\\n\\nsignal:Connect(function(msg)\\n\\tprint(\\"Got message:\\", msg)\\nend)\\n\\nsignal:Fire(\\"Hello world!\\")\\n```","source":{"line":119,"path":"packages/signal/init.lua"}}')}}]);